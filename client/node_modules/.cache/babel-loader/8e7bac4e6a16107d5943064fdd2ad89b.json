{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _map2 = require('lodash/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _flatten2 = require('lodash/flatten');\n\nvar _flatten3 = _interopRequireDefault(_flatten2);\n\nvar _chunk2 = require('lodash/chunk');\n\nvar _chunk3 = _interopRequireDefault(_chunk2);\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _Promise = require('../Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _stream = require('stream');\n\nvar _fs = require('fs');\n\nvar _helpers = require('../helpers.js');\n\nvar _errors = require('../errors.js');\n\nvar _RedditContent = require('./RedditContent.js');\n\nvar _RedditContent2 = _interopRequireDefault(_RedditContent);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar api_type = 'json';\n/**\n* A class representing a subreddit\n* <style> #Subreddit {display: none} </style>\n* @extends RedditContent\n* @example\n*\n* // Get a subreddit by name\n* r.getSubreddit('AskReddit')\n*/\n\nvar Subreddit =\n/*#__PURE__*/\nfunction (_RedditContent2$defau) {\n  _inherits(Subreddit, _RedditContent2$defau);\n\n  function Subreddit() {\n    _classCallCheck(this, Subreddit);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Subreddit).apply(this, arguments));\n  }\n\n  _createClass(Subreddit, [{\n    key: \"_transformApiResponse\",\n    value: function _transformApiResponse(response) {\n      if (!(response instanceof Subreddit)) {\n        throw new TypeError('The subreddit /r/' + this.display_name + ' does not exist.');\n      }\n\n      return response;\n    }\n  }, {\n    key: \"_deleteFlairTemplates\",\n    value: function _deleteFlairTemplates(_ref) {\n      var flair_type = _ref.flair_type;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/clearflairtemplates',\n        form: {\n          api_type: api_type,\n          flair_type: flair_type\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Deletes all of this subreddit's user flair templates\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteAllUserFlairTemplates()\n    */\n\n  }, {\n    key: \"deleteAllUserFlairTemplates\",\n    value: function deleteAllUserFlairTemplates() {\n      return this._deleteFlairTemplates({\n        flair_type: 'USER_FLAIR'\n      });\n    }\n    /**\n    * @summary Deletes all of this subreddit's link flair templates\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteAllLinkFlairTemplates()\n    */\n\n  }, {\n    key: \"deleteAllLinkFlairTemplates\",\n    value: function deleteAllLinkFlairTemplates() {\n      return this._deleteFlairTemplates({\n        flair_type: 'LINK_FLAIR'\n      });\n    }\n    /**\n    * @summary Deletes one of this subreddit's flair templates\n    * @param {object} options\n    * @param {string} options.flair_template_id The ID of the template that should be deleted\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteFlairTemplate({flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721'})\n    */\n\n  }, {\n    key: \"deleteFlairTemplate\",\n    value: function deleteFlairTemplate(_ref2) {\n      var flair_template_id = _ref2.flair_template_id;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/deleteflairtemplate',\n        form: {\n          api_type: api_type,\n          flair_template_id: flair_template_id\n        }\n      }).return(this);\n    }\n  }, {\n    key: \"_createFlairTemplate\",\n    value: function _createFlairTemplate(_ref3) {\n      var text = _ref3.text,\n          css_class = _ref3.css_class,\n          _ref3$cssClass = _ref3.cssClass,\n          cssClass = _ref3$cssClass === undefined ? css_class : _ref3$cssClass,\n          flair_type = _ref3.flair_type,\n          _ref3$text_editable = _ref3.text_editable,\n          text_editable = _ref3$text_editable === undefined ? false : _ref3$text_editable,\n          _ref3$textEditable = _ref3.textEditable,\n          textEditable = _ref3$textEditable === undefined ? text_editable : _ref3$textEditable;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/flairtemplate',\n        form: {\n          api_type: api_type,\n          text: text,\n          css_class: cssClass,\n          flair_type: flair_type,\n          text_editable: textEditable\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Creates a new user flair template for this subreddit\n    * @param {object} options\n    * @param {string} options.text The flair text for this template\n    * @param {string} [options.cssClass=''] The CSS class for this template\n    * @param {boolean} [options.textEditable=false] Determines whether users should be able to edit their flair text\n    when it has this template\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').createUserFlairTemplate({text: 'Some Flair Text', cssClass: 'some-css-class'})\n    */\n\n  }, {\n    key: \"createUserFlairTemplate\",\n    value: function createUserFlairTemplate(options) {\n      return this._createFlairTemplate(_extends({}, options, {\n        flair_type: 'USER_FLAIR'\n      }));\n    }\n    /**\n    * @summary Creates a new link flair template for this subreddit\n    * @param {object} options\n    * @param {string} options.text The flair text for this template\n    * @param {string} [options.cssClass=''] The CSS class for this template\n    * @param {boolean} [options.textEditable=false] Determines whether users should be able to edit the flair text of their\n    links when it has this template\n    * @returns {Promise} A Promise that fulfills with this Subredit when the request is complete.\n    * @example r.getSubreddit('snoowrap').createLinkFlairTemplate({text: 'Some Flair Text', cssClass: 'some-css-class'})\n    */\n\n  }, {\n    key: \"createLinkFlairTemplate\",\n    value: function createLinkFlairTemplate(options) {\n      return this._createFlairTemplate(_extends({}, options, {\n        flair_type: 'LINK_FLAIR'\n      }));\n    }\n  }, {\n    key: \"_getFlairOptions\",\n    value: function _getFlairOptions() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          name = _ref4.name,\n          link = _ref4.link; // TODO: Add shortcuts for this on RedditUser and Submission\n\n\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/flairselector',\n        form: {\n          name: name,\n          link: link\n        }\n      });\n    }\n    /**\n    * @summary Gets the flair templates for a given link.\n    * @param {string} linkId The link's base36 ID\n    * @returns {Promise} An Array of flair template options\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getLinkFlairTemplates('4fp36y').then(console.log)\n    // => [ { flair_css_class: '',\n    //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n    //  flair_text_editable: true,\n    //  flair_position: 'right',\n    //  flair_text: '' },\n    //  { flair_css_class: '',\n    //  flair_template_id: '03821f62-c920-11e5-b608-0e309fbcf863',\n    //  flair_text_editable: true,\n    //  flair_position: 'right',\n    //  flair_text: '' },\n    //  ...\n    // ]\n    */\n\n  }, {\n    key: \"getLinkFlairTemplates\",\n    value: function getLinkFlairTemplates(linkId) {\n      return this._getFlairOptions({\n        link: linkId\n      }).get('choices');\n    }\n    /**\n    * @summary Gets the list of user flair templates on this subreddit.\n    * @returns {Promise} An Array of user flair templates\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getUserFlairTemplates().then(console.log)\n    // => [ { flair_css_class: '',\n    //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n    //  flair_text_editable: true,\n    //  flair_position: 'right',\n    //  flair_text: '' },\n    //  { flair_css_class: '',\n    //  flair_template_id: '03821f62-c920-11e5-b608-0e309fbcf863',\n    //  flair_text_editable: true,\n    //  flair_position: 'right',\n    //  flair_text: '' },\n    //  ...\n    // ]\n    */\n\n  }, {\n    key: \"getUserFlairTemplates\",\n    value: function getUserFlairTemplates() {\n      return this._getFlairOptions().get('choices');\n    }\n    /**\n    * @summary Clears a user's flair on this subreddit.\n    * @param {string} name The user's name\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteUserFlair('actually_an_aardvark')\n    */\n\n  }, {\n    key: \"deleteUserFlair\",\n    value: function deleteUserFlair(name) {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/deleteflair',\n        form: {\n          api_type: api_type,\n          name: name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Gets a user's flair on this subreddit.\n    * @param {string} name The user's name\n    * @returns {Promise} An object representing the user's flair\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getUserFlair('actually_an_aardvark').then(console.log)\n    // => { flair_css_class: '',\n    //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n    //  flair_text: '',\n    //  flair_position: 'right'\n    // }\n    */\n\n  }, {\n    key: \"getUserFlair\",\n    value: function getUserFlair(name) {\n      return this._getFlairOptions({\n        name: name\n      }).get('current');\n    }\n    /**\n    * @summary Sets multiple user flairs at the same time\n    * @desc Due to the behavior of the reddit API endpoint that this function uses, if any of the provided user flairs are\n    invalid, reddit will make note of this in its response, but it will still attempt to set the remaining user flairs. If this\n    occurs, the Promise returned by snoowrap will be rejected, and the rejection reason will be an array containing the 'error'\n    responses from reddit.\n    * @param {object[]} flairArray\n    * @param {string} flairArray[].name A user's name\n    * @param {string} flairArray[].text The flair text to assign to this user\n    * @param {string} flairArray[].cssClass The flair CSS class to assign to this user\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example\n    * r.getSubreddit('snoowrap').setMultipleUserFlairs([\n    *   {name: 'actually_an_aardvark', text: \"this is /u/actually_an_aardvark's flair text\", cssClass: 'some-css-class'},\n    *   {name: 'snoowrap_testing', text: \"this is /u/snoowrap_testing's flair text\", cssClass: 'some-css-class'}\n    * ]);\n    * // the above request gets completed successfully\n    *\n    * r.getSubreddit('snoowrap').setMultipleUserFlairs([\n    *   {name: 'actually_an_aardvark', text: 'foo', cssClass: 'valid-css-class'},\n    *   {name: 'snoowrap_testing', text: 'bar', cssClass: \"this isn't a valid css class\"},\n    *   {name: 'not_an_aardvark', text: 'baz', cssClass: \"this also isn't a valid css class\"}\n    * ])\n    * // the Promise from the above request gets rejected, with the following rejection reason:\n    * [\n    *   {\n    *     status: 'skipped',\n    *     errors: { css: 'invalid css class `this isn\\'t a valid css class\\', ignoring' },\n    *     ok: false,\n    *     warnings: {}\n    *   },\n    *   {\n    *     status: 'skipped',\n    *     errors: { css: 'invalid css class `this also isn\\'t a valid css class\\', ignoring' },\n    *     ok: false,\n    *     warnings: {}\n    *   }\n    * ]\n    * // note that /u/actually_an_aardvark's flair still got set by the request, even though the other two flairs caused errors.\n    */\n\n  }, {\n    key: \"setMultipleUserFlairs\",\n    value: function setMultipleUserFlairs(flairArray) {\n      var _this = this;\n\n      var csvLines = flairArray.map(function (item) {\n        // reddit expects to receive valid CSV data, which each line having the form `username,flair_text,css_class`.\n        return [item.name, item.text || item.flairText || item.flair_text || '', item.cssClass || item.css_class || item.flairCssClass || item.flair_css_class || ''].map(function (str) {\n          /* To escape special characters in the lines (e.g. if the flair text itself contains a comma), surround each\n          part of the line with double quotes before joining the parts together with commas (in accordance with how special\n          characters are usually escaped in CSV). If double quotes are themselves part of the flair text, replace them with a\n          pair of consecutive double quotes. */\n          return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n        }).join(',');\n      });\n      /* Due to an API limitation, this endpoint can only set the flair of 100 users at a time.\n      Send multiple requests if necessary to ensure that all users in the array are accounted for. */\n\n      return _Promise2.default.map((0, _chunk3.default)(csvLines, 100), function (flairChunk) {\n        return _this._post({\n          uri: 'r/' + _this.display_name + '/api/flaircsv',\n          form: {\n            flair_csv: flairChunk.join('\\n')\n          }\n        });\n      }).then(_flatten3.default).tap(function (results) {\n        var errorRows = results.filter(function (row) {\n          return !row.ok;\n        });\n\n        if (errorRows.length) {\n          throw errorRows;\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Gets a list of all user flairs on this subreddit.\n    * @param {object} options\n    * @param {string} [options.name] A specific username to jump to\n    * @returns {Promise} A Listing containing user flairs\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getUserFlairList().then(console.log)\n    // => Listing [\n    //  { flair_css_class: null,\n    //  user: 'not_an_aardvark',\n    //  flair_text: 'Isn\\'t an aardvark' },\n    //  { flair_css_class: 'some-css-class',\n    //    user: 'actually_an_aardvark',\n    //    flair_text: 'this is /u/actually_an_aardvark\\'s flair text' },\n    //  { flair_css_class: 'some-css-class',\n    //    user: 'snoowrap_testing',\n    //    flair_text: 'this is /u/snoowrap_testing\\'s flair text' }\n    // ]\n    */\n\n  }, {\n    key: \"getUserFlairList\",\n    value: function getUserFlairList() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/api/flairlist',\n        qs: options,\n        _transform: function _transform(response) {\n          /* For unknown reasons, responses from the api/flairlist endpoint are formatted differently than responses from all other\n          Listing endpoints. Most Listing endpoints return an object with a `children` property containing the Listing's children,\n          and `after` and `before` properties corresponding to the `after` and `before` querystring parameters that a client should\n          use in the next request. However, the api/flairlist endpoint returns an objecti with a `users` property containing the\n          Listing's children, and `next` and `prev` properties corresponding to the `after` and `before` querystring parameters. As\n          far as I can tell, there's no actual reason for this difference. >_> */\n          response.after = response.next || null;\n          response.before = response.prev || null;\n          response.children = response.users;\n          return _this2._r._newObject('Listing', response);\n        }\n      });\n    }\n    /**\n    * @summary Configures the flair settings for this subreddit.\n    * @param {object} options\n    * @param {boolean} options.userFlairEnabled Determines whether user flair should be enabled\n    * @param {string} options.userFlairPosition Determines the orientation of user flair relative to a given username. This\n    should be either the string 'left' or the string 'right'.\n    * @param {boolean} options.userFlairSelfAssignEnabled Determines whether users should be able to edit their own flair\n    * @param {string} options.linkFlairPosition Determines the orientation of link flair relative to a link title. This should\n    be either 'left' or 'right'.\n    * @param {boolean} options.linkFlairSelfAssignEnabled Determines whether users should be able to edit the flair of their\n    submissions.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').configure_flair({\n      userFlairEnabled: true,\n      userFlairPosition: 'left',\n      userFlairSelfAssignEnabled: false,\n      linkFlairPosition: 'right',\n      linkFlairSelfAssignEnabled: false\n    * })\n    */\n\n  }, {\n    key: \"configureFlair\",\n    value: function configureFlair(_ref5) {\n      var user_flair_enabled = _ref5.user_flair_enabled,\n          _ref5$userFlairEnable = _ref5.userFlairEnabled,\n          userFlairEnabled = _ref5$userFlairEnable === undefined ? user_flair_enabled : _ref5$userFlairEnable,\n          user_flair_position = _ref5.user_flair_position,\n          _ref5$userFlairPositi = _ref5.userFlairPosition,\n          userFlairPosition = _ref5$userFlairPositi === undefined ? user_flair_position : _ref5$userFlairPositi,\n          user_flair_self_assign_enabled = _ref5.user_flair_self_assign_enabled,\n          _ref5$userFlairSelfAs = _ref5.userFlairSelfAssignEnabled,\n          userFlairSelfAssignEnabled = _ref5$userFlairSelfAs === undefined ? user_flair_self_assign_enabled : _ref5$userFlairSelfAs,\n          link_flair_position = _ref5.link_flair_position,\n          _ref5$linkFlairPositi = _ref5.linkFlairPosition,\n          linkFlairPosition = _ref5$linkFlairPositi === undefined ? link_flair_position : _ref5$linkFlairPositi,\n          link_flair_self_assign_enabled = _ref5.link_flair_self_assign_enabled,\n          _ref5$linkFlairSelfAs = _ref5.linkFlairSelfAssignEnabled,\n          linkFlairSelfAssignEnabled = _ref5$linkFlairSelfAs === undefined ? link_flair_self_assign_enabled : _ref5$linkFlairSelfAs;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/flairconfig',\n        form: {\n          api_type: api_type,\n          flair_enabled: userFlairEnabled,\n          flair_position: userFlairPosition,\n          flair_self_assign_enabled: userFlairSelfAssignEnabled,\n          link_flair_position: linkFlairPosition,\n          link_flair_self_assign_enabled: linkFlairSelfAssignEnabled\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Gets the requester's flair on this subreddit.\n    * @returns {Promise} An object representing the requester's current flair\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getMyFlair().then(console.log)\n    // => { flair_css_class: 'some-css-class',\n    //  flair_template_id: null,\n    //  flair_text: 'this is /u/snoowrap_testing\\'s flair text',\n    //  flair_position: 'right'\n    // }\n    */\n\n  }, {\n    key: \"getMyFlair\",\n    value: function getMyFlair() {\n      return this._getFlairOptions().get('current');\n    }\n    /**\n    * @summary Sets the requester's flair on this subreddit.\n    * @param {object} options\n    * @param {string} options.flair_template_id A flair template ID to use. (This should be obtained beforehand using\n    {@link getUserFlairTemplates}.)\n    * @param {string} [options.text] The flair text to use. (This is only necessary/useful if the given flair\n    template has the `text_editable` property set to `true`.)\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').selectMyFlair({flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721'})\n    */\n\n  }, {\n    key: \"selectMyFlair\",\n    value: function selectMyFlair(options) {\n      var _this3 = this;\n      /* NOTE: This requires `identity` scope in addition to `flair` scope, since the reddit api needs to be passed a username.\n      I'm not sure if there's a way to do this without requiring additional scope. */\n\n\n      return this._r._getMyName().then(function (name) {\n        return _this3._r._selectFlair(_extends({}, options, {\n          subredditName: _this3.display_name,\n          name: name\n        }));\n      }).return(this);\n    }\n  }, {\n    key: \"_setMyFlairVisibility\",\n    value: function _setMyFlairVisibility(flair_enabled) {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/setflairenabled',\n        form: {\n          api_type: api_type,\n          flair_enabled: flair_enabled\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Makes the requester's flair visible on this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').showMyFlair()\n    */\n\n  }, {\n    key: \"showMyFlair\",\n    value: function showMyFlair() {\n      return this._setMyFlairVisibility(true);\n    }\n    /**\n    * @summary Makes the requester's flair invisible on this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').hideMyFlair()\n    */\n\n  }, {\n    key: \"hideMyFlair\",\n    value: function hideMyFlair() {\n      return this._setMyFlairVisibility(false);\n    }\n    /**\n    * @summary Creates a new selfpost on this subreddit.\n    * @param {object} options An object containing details about the submission\n    * @param {string} options.title The title of the submission\n    * @param {string} [options.text] The selftext of the submission\n    * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n    * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n    requires a captcha to submit posts and comments.\n    * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n    * @returns {Promise} The newly-created Submission object\n    * @example\n    *\n    * r.getSubreddit('snoowrap').submitSelfpost({title: 'this is a selfpost', text: \"hi, how's it going?\"}).then(console.log)\n    * // => Submission { name: 't3_4abmsz' }\n    */\n\n  }, {\n    key: \"submitSelfpost\",\n    value: function submitSelfpost(options) {\n      return this._r.submitSelfpost(_extends({}, options, {\n        subredditName: this.display_name\n      }));\n    }\n    /**\n    * @summary Creates a new link submission on this subreddit.\n    * @param {object} options An object containing details about the submission\n    * @param {string} options.title The title of the submission\n    * @param {string} options.url The url that the link submission should point to\n    * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n    * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n    the past, reddit will return an error. This could be used to avoid accidental reposts.\n    * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n    requires a captcha to submit posts and comments.\n    * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n    * @returns {Promise} The newly-created Submission object\n    * @example\n    *\n    * r.getSubreddit('snoowrap').submitLink({title: 'I found a cool website', url: 'https://google.com'}).then(console.log)\n    * // => Submission { name: 't3_4abmsz' }\n    */\n\n  }, {\n    key: \"submitLink\",\n    value: function submitLink(options) {\n      return this._r.submitLink(_extends({}, options, {\n        subredditName: this.display_name\n      }));\n    }\n    /**\n     * @summary Creates a new crosspost submission on this subreddit\n     * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n     * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n     * @param {object} options An object containing details about the submission\n     * @param {string} options.title The title of the crosspost\n     * @param {string|Submission} options.originalPost A Submission object or a post ID for the original post which\n     is being crossposted\n     * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n     * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n     the past, reddit will return an error. This could be used to avoid accidental reposts.\n     * @returns {Promise} The newly-created Submission object\n     * @example\n     *\n     * await r.getSubreddit('snoowrap').submitCrosspost({ title: 'I found an interesting post', originalPost: '6vths0' })\n     * // => Submission { name: 't3_4abmsz' }\n     */\n\n  }, {\n    key: \"submitCrosspost\",\n    value: function submitCrosspost(options) {\n      return this._r.submitCrosspost(_extends({}, options, {\n        subredditName: this.display_name\n      }));\n    }\n    /**\n    * @summary Gets a Listing of hot posts on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @returns {Promise} A Listing containing the retrieved submissions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getHot().then(console.log)\n    * // => Listing [\n    * //  Submission { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getHot\",\n    value: function getHot(options) {\n      return this._r.getHot(this.display_name, options);\n    }\n    /**\n    * @summary Gets a Listing of new posts on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @returns {Promise} A Listing containing the retrieved submissions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getNew().then(console.log)\n    * // => Listing [\n    * //  Submission { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    *\n    */\n\n  }, {\n    key: \"getNew\",\n    value: function getNew(options) {\n      return this._r.getNew(this.display_name, options);\n    }\n    /**\n    * @summary Gets a Listing of new comments on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @returns {Promise} A Listing containing the retrieved comments\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getNewComments().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getNewComments\",\n    value: function getNewComments(options) {\n      return this._r.getNewComments(this.display_name, options);\n    }\n    /**\n    * @summary Gets a single random Submission from this subreddit.\n    * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n    redirect which cannot be followed by a CORS request.\n    * @returns {Promise} The retrieved Submission object\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getRandomSubmission.then(console.log)\n    * // => Submission { ... }\n    */\n\n  }, {\n    key: \"getRandomSubmission\",\n    value: function getRandomSubmission() {\n      return this._r.getRandomSubmission(this.display_name);\n    }\n    /**\n    * @summary Gets a Listing of top posts on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n    `hour, day, week, month, year, all`\n    * @returns {Promise} A Listing containing the retrieved submissions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getTop({time: 'all'}).then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getTop\",\n    value: function getTop(options) {\n      return this._r.getTop(this.display_name, options);\n    }\n    /**\n    * @summary Gets a Listing of controversial posts on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n    `hour, day, week, month, year, all`\n    * @returns {Promise} A Listing containing the retrieved submissions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getControversial({time: 'week'}).then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getControversial\",\n    value: function getControversial(options) {\n      return this._r.getControversial(this.display_name, options);\n    }\n    /**\n    * @summary Gets a Listing of top posts on this subreddit.\n    * @param {object} [options] Options for the resulting Listing\n    * @returns {Promise} A Listing containing the retrieved submissions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getRising().then(console.log)\n    * // => Listing [\n    * //  Submission { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getRising\",\n    value: function getRising(options) {\n      return this._r.getRising(this.display_name, options);\n    }\n    /**\n    * @summary Gets the moderator mail for this subreddit.\n    * @param {object} [options] Options for the resulting Listing\n    * @returns {Promise} A Listing containing PrivateMessage objects\n    * @example r.getSubreddit('snoowrap').getModmail().then(console.log)\n    */\n\n  }, {\n    key: \"getModmail\",\n    value: function getModmail(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/message/moderator',\n        qs: options\n      });\n    }\n    /**\n    * @summary Gets the moderation log for this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string[]} [options.mods] An array of moderator names that the results should be restricted to\n    * @param {string} [options.type] Restricts the results to the specified type. This should be one of `banuser, unbanuser,\n    removelink, approvelink, removecomment, approvecomment, addmoderator, invitemoderator, uninvitemoderator,\n    acceptmoderatorinvite, removemoderator, addcontributor, removecontributor, editsettings, editflair, distinguish, marknsfw,\n    wikibanned, wikicontributor, wikiunbanned, wikipagelisted, removewikicontributor, wikirevise, wikipermlevel,\n    ignorereports, unignorereports, setpermissions, setsuggestedsort, sticky, unsticky, setcontestmode, unsetcontestmode,\n    lock, unlock, muteuser, unmuteuser, createrule, editrule, deleterule, spoiler, unspoiler`\n    * @returns {Promise} A Listing containing moderation actions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getModerationLog().then(console.log)\n    *\n    * // => Listing [\n    * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'editflair', ... }\n    * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'approvecomment', ... }\n    * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'createrule', ... }\n    * // ]\n    */\n\n  }, {\n    key: \"getModerationLog\",\n    value: function getModerationLog() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var parsedOptions = (0, _omit3.default)(_extends({}, options, {\n        mod: options.mods && options.mods.join(',')\n      }), 'mods');\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/log',\n        qs: parsedOptions\n      });\n    }\n    /**\n    * @summary Gets a list of reported items on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n    * @returns {Promise} A Listing containing reported items\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getReports().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getReports\",\n    value: function getReports() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/reports',\n        qs: options\n      });\n    }\n    /**\n    * @summary Gets a list of removed items on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n    * @returns {Promise} A Listing containing removed items\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getSpam().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getSpam\",\n    value: function getSpam() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/spam',\n        qs: options\n      });\n    }\n    /**\n    * @summary Gets a list of items on the modqueue on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n    * @returns {Promise} A Listing containing items on the modqueue\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getModqueue().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getModqueue\",\n    value: function getModqueue() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/modqueue',\n        qs: options\n      });\n    }\n    /**\n    * @summary Gets a list of unmoderated items on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n    * @returns {Promise} A Listing containing unmoderated items\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getUnmoderated().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getUnmoderated\",\n    value: function getUnmoderated() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/unmoderated',\n        qs: options\n      });\n    }\n    /**\n    * @summary Gets a list of edited items on this subreddit.\n    * @param {object} [options={}] Options for the resulting Listing\n    * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n    * @returns {Promise} A Listing containing edited items\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getEdited().then(console.log)\n    * // => Listing [\n    * //  Comment { ... },\n    * //  Comment { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getEdited\",\n    value: function getEdited() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/edited',\n        qs: options\n      });\n    }\n    /**\n    * @summary Accepts an invite to become a moderator of this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').acceptModeratorInvite()\n    */\n\n  }, {\n    key: \"acceptModeratorInvite\",\n    value: function acceptModeratorInvite() {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/accept_moderator_invite',\n        form: {\n          api_type: api_type\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Abdicates moderator status on this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').leaveModerator()\n    */\n\n  }, {\n    key: \"leaveModerator\",\n    value: function leaveModerator() {\n      var _this4 = this;\n\n      return this.fetch().get('name').then(function (name) {\n        return _this4._post({\n          uri: 'api/leavemoderator',\n          form: {\n            id: name\n          }\n        }).then((0, _helpers.handleJsonErrors)(_this4));\n      });\n    }\n    /**\n    * @summary Abdicates approved submitter status on this subreddit.\n    * @returns {Promise} A Promise that resolves with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').leaveContributor()\n    */\n\n  }, {\n    key: \"leaveContributor\",\n    value: function leaveContributor() {\n      var _this5 = this;\n\n      return this.fetch().get('name').then(function (name) {\n        return _this5._post({\n          uri: 'api/leavecontributor',\n          form: {\n            id: name\n          }\n        }).return(_this5);\n      });\n    }\n    /**\n    * @summary Gets a subreddit's CSS stylesheet.\n    * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n    redirect which cannot be followed by a CORS request.\n    * @desc **Note**: This method will return a 404 error if the subreddit in question does not have a custom stylesheet.\n    * @returns {Promise} A Promise for a string containing the subreddit's CSS.\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getStylesheet().then(console.log)\n    * // => '.md blockquote,.md del,body{color:#121212}.usertext-body ... '\n    */\n\n  }, {\n    key: \"getStylesheet\",\n    value: function getStylesheet() {\n      return this._get({\n        uri: 'r/' + this.display_name + '/stylesheet',\n        json: false\n      });\n    }\n    /**\n    * @summary Conducts a search of reddit submissions, restricted to this subreddit.\n    * @param {object} options Search options. Can also contain options for the resulting Listing.\n    * @param {string} options.query The search query\n    * @param {string} [options.time] Describes the timespan that posts should be retrieved frome. One of\n    `hour, day, week, month, year, all`\n    * @param {string} [options.sort] Determines how the results should be sorted. One of `relevance, hot, top, new, comments`\n    * @param {string} [options.syntax='plain'] Specifies a syntax for the search. One of `cloudsearch, lucene, plain`\n    * @returns {Promise} A Listing containing the search results.\n    * @example\n    *\n    * r.getSubreddit('snoowrap').search({query: 'blah', sort: 'year'}).then(console.log)\n    * // => Listing [\n    * //  Submission { ... },\n    * //  Submission { ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"search\",\n    value: function search(options) {\n      return this._r.search(_extends({}, options, {\n        subreddit: this,\n        restrictSr: true\n      }));\n    }\n    /**\n    * @summary Gets the list of banned users on this subreddit.\n    * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n    * @param {string} options.name A username on the list to jump to.\n    * @returns {Promise} A Listing of users\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getBannedUsers().then(console.log)\n    * // => Listing [\n    * //  { date: 1461720936, note: '', name: 'actually_an_aardvark', id: 't2_q3519' }\n    * //  ...\n    * // ]\n    *\n    */\n\n  }, {\n    key: \"getBannedUsers\",\n    value: function getBannedUsers(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/banned',\n        qs: (0, _helpers.renameKey)(options, 'name', 'user')\n      });\n    }\n    /**\n    * @summary Gets the list of muted users on this subreddit.\n    * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n    * @param {string} options.name A username on the list to jump to.\n    * @returns {Promise} A Listing of users\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getBannedUsers().then(console.log)\n    * // => Listing [\n    * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getMutedUsers\",\n    value: function getMutedUsers(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/muted',\n        qs: (0, _helpers.renameKey)(options, 'name', 'user')\n      });\n    }\n    /**\n    * @summary Gets the list of users banned from this subreddit's wiki.\n    * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n    * @param {string} options.name A username on the list to jump to.\n    * @returns {Promise} A Listing of users\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getWikibannedUsers().then(console.log)\n    * // => Listing [\n    * //  { date: 1461720936, note: '', name: 'actually_an_aardvark', id: 't2_q3519' }\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getWikibannedUsers\",\n    value: function getWikibannedUsers(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/wikibanned',\n        qs: (0, _helpers.renameKey)(options, 'name', 'user')\n      });\n    }\n    /**\n    * @summary Gets the list of approved submitters on this subreddit.\n    * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n    * @param {string} options.name A username on the list to jump to.\n    * @returns {Promise} A Listing of users\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getContributors().then(console.log)\n    * // => Listing [\n    * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getContributors\",\n    value: function getContributors(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/contributors',\n        qs: (0, _helpers.renameKey)(options, 'name', 'user')\n      });\n    }\n    /**\n    * @summary Gets the list of approved wiki submitters on this subreddit .\n    * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n    * @param {string} options.name A username on the list to jump to.\n    * @returns {Promise} A Listing of users\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getWikiContributors().then(console.log)\n    * // => Listing [\n    * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getWikiContributors\",\n    value: function getWikiContributors(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/about/wikicontributors',\n        qs: (0, _helpers.renameKey)(options, 'name', 'user')\n      });\n    }\n    /**\n    * @summary Gets the list of moderators on this subreddit.\n    * @param {object} options\n    * @param {string} [options.name] The name of a user to find in the list\n    * @returns {Promise} An Array of RedditUsers representing the moderators of this subreddit\n    * @example\n    *\n    * r.getSubreddit('AskReddit').getModerators().then(console.log)\n    * // => [\n    * //  RedditUser { date: 1453862639, mod_permissions: [ 'all' ], name: 'not_an_aardvark', id: 't2_k83md' },\n    * //  ...\n    * // ]\n    *\n    */\n\n  }, {\n    key: \"getModerators\",\n    value: function getModerators() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          name = _ref6.name;\n\n      return this._get({\n        uri: 'r/' + this.display_name + '/about/moderators',\n        qs: {\n          user: name\n        }\n      });\n    }\n    /**\n    * @summary Deletes the banner for this Subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteBanner()\n    */\n\n  }, {\n    key: \"deleteBanner\",\n    value: function deleteBanner() {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/delete_sr_banner',\n        form: {\n          api_type: api_type\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Deletes the header image for this Subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteHeader()\n    */\n\n  }, {\n    key: \"deleteHeader\",\n    value: function deleteHeader() {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/delete_sr_header',\n        form: {\n          api_type: api_type\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Deletes this subreddit's icon.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteIcon()\n    */\n\n  }, {\n    key: \"deleteIcon\",\n    value: function deleteIcon() {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/delete_sr_icon',\n        form: {\n          api_type: api_type\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Deletes an image from this subreddit.\n    * @param {object} options\n    * @param {string} options.imageName The name of the image.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').deleteImage()\n    */\n\n  }, {\n    key: \"deleteImage\",\n    value: function deleteImage(_ref7) {\n      var image_name = _ref7.image_name,\n          _ref7$imageName = _ref7.imageName,\n          imageName = _ref7$imageName === undefined ? image_name : _ref7$imageName;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/delete_sr_img',\n        form: {\n          api_type: api_type,\n          img_name: imageName\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Gets this subreddit's current settings.\n    * @returns {Promise} An Object containing this subreddit's current settings.\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getSettings().then(console.log)\n    * // => SubredditSettings { default_set: true, submit_text: '', subreddit_type: 'private', ... }\n    */\n\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return this._get({\n        uri: 'r/' + this.display_name + '/about/edit'\n      });\n    }\n    /**\n    * @summary Edits this subreddit's settings.\n    * @param {object} options An Object containing {[option name]: new value} mappings of the options that should be modified.\n    Any omitted option names will simply retain their previous values.\n    * @param {string} options.title The text that should appear in the header of the subreddit\n    * @param {string} options.public_description The text that appears with this Subreddit on the search page, or on the\n    blocked-access page if this subreddit is private. (500 characters max)\n    * @param {string} options.description The sidebar text for the subreddit. (5120 characters max)\n    * @param {string} [options.submit_text=''] The text to show below the submission page (1024 characters max)\n    * @param {boolean} [options.hide_ads=false] Determines whether ads should be hidden on this subreddit. (This is only\n    allowed for gold-only subreddits.)\n    * @param {string} [options.lang='en'] The language of the subreddit (represented as an IETF language tag)\n    * @param {string} [options.type='public'] Determines who should be able to access the subreddit. This should be one of\n    `public, private, restricted, gold_restricted, gold_only, archived, employees_only`.\n    * @param {string} [options.link_type='any'] Determines what types of submissions are allowed on the subreddit. This should\n    be one of `any, link, self`.\n    * @param {string} [options.submit_link_label=undefined] Custom text to display on the button that submits a link. If\n    this is omitted, the default text will be displayed.\n    * @param {string} [options.submit_text_label=undefined] Custom text to display on the button that submits a selfpost. If\n    this is omitted, the default text will be displayed.\n    * @param {string} [options.wikimode='modonly'] Determines who can edit wiki pages on the subreddit. This should be one of\n    `modonly, anyone, disabled`.\n    * @param {number} [options.wiki_edit_karma=0] The minimum amount of subreddit karma needed for someone to edit this\n    subreddit's wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n    * @param {number} [options.wiki_edit_age=0] The minimum account age (in days) needed for someone to edit this subreddit's\n    wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n    * @param {string} [options.spam_links='high'] The spam filter strength for links on this subreddit. This should be one of\n    `low, high, all`.\n    * @param {string} [options.spam_selfposts='high'] The spam filter strength for selfposts on this subreddit. This should be\n    one of `low, high, all`.\n    * @param {string} [options.spam_comments='high'] The spam filter strength for comments on this subreddit. This should be one\n    of `low, high, all`.\n    * @param {boolean} [options.over_18=false] Determines whether this subreddit should be classified as NSFW\n    * @param {boolean} [options.allow_top=true] Determines whether the new subreddit should be able to appear in /r/all and\n    trending subreddits\n    * @param {boolean} [options.show_media=false] Determines whether image thumbnails should be enabled on this subreddit\n    * @param {boolean} [options.show_media_preview=true] Determines whether media previews should be expanded by default on this\n    subreddit\n    * @param {boolean} [options.allow_images=true] Determines whether image uploads and links to image hosting sites should be\n    enabled on this subreddit\n    * @param {boolean} [options.exclude_banned_modqueue=false] Determines whether posts by site-wide banned users should be\n    excluded from the modqueue.\n    * @param {boolean} [options.public_traffic=false] Determines whether the /about/traffic page for this subreddit should be\n    viewable by anyone.\n    * @param {boolean} [options.collapse_deleted_comments=false] Determines whether deleted and removed comments should be\n    collapsed by default\n    * @param {string} [options.suggested_comment_sort=undefined] The suggested comment sort for the subreddit. This should be\n    one of `confidence, top, new, controversial, old, random, qa`.If left blank, there will be no suggested sort,\n    which means that users will see the sort method that is set in their own preferences (usually `confidence`.)\n    * @param {boolean} [options.spoilers_enabled=false] Determines whether users can mark their posts as spoilers\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').editSettings({submit_text: 'Welcome! Please be sure to read the rules.'})\n    */\n\n  }, {\n    key: \"editSettings\",\n    value: function editSettings(options) {\n      var _this6 = this;\n\n      return _Promise2.default.join(this.getSettings(), this.fetch().get('name'), function (currentValues, name) {\n        return _this6._r._createOrEditSubreddit(_extends({}, (0, _helpers.renameKey)(currentValues, 'subreddit_type', 'type'), options, {\n          sr: name\n        }));\n      }).return(this);\n    }\n    /**\n    * @summary Gets a list of recommended other subreddits given this one.\n    * @param {object} [options]\n    * @param {Array} [options.omit=[]] An Array of subreddit names that should be excluded from the listing.\n    * @returns {Promise} An Array of subreddit names\n    * @example\n    *\n    * r.getSubreddit('AskReddit').getRecommendedSubreddits().then(console.log);\n    * // [ 'TheChurchOfRogers', 'Sleepycabin', ... ]\n    */\n\n  }, {\n    key: \"getRecommendedSubreddits\",\n    value: function getRecommendedSubreddits(options) {\n      var toOmit = options.omit && options.omit.join(',');\n      return this._get({\n        uri: 'api/recommend/sr/' + this.display_name,\n        qs: {\n          omit: toOmit\n        }\n      }).then(function (names) {\n        return (0, _map3.default)(names, 'sr_name');\n      });\n    }\n    /**\n    * @summary Gets the submit text (which displays on the submission form) for this subreddit.\n    * @returns {Promise} The submit text, represented as a string.\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getSubmitText().then(console.log)\n    * // => 'Welcome! Please be sure to read the rules.'\n    */\n\n  }, {\n    key: \"getSubmitText\",\n    value: function getSubmitText() {\n      return this._get({\n        uri: 'r/' + this.display_name + '/api/submit_text'\n      }).get('submit_text');\n    }\n    /**\n    * @summary Updates this subreddit's stylesheet.\n    * @param {object} options\n    * @param {string} options.css The new contents of the stylesheet\n    * @param {string} [options.reason] The reason for the change (256 characters max)\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').updateStylesheet({css: 'body {color:#00ff00;}', reason: 'yay green'})\n    */\n\n  }, {\n    key: \"updateStylesheet\",\n    value: function updateStylesheet(_ref8) {\n      var css = _ref8.css,\n          reason = _ref8.reason;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/subreddit_stylesheet',\n        form: {\n          api_type: api_type,\n          op: 'save',\n          reason: reason,\n          stylesheet_contents: css\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n  }, {\n    key: \"_setSubscribed\",\n    value: function _setSubscribed(status) {\n      return this._post({\n        uri: 'api/subscribe',\n        form: {\n          action: status ? 'sub' : 'unsub',\n          sr_name: this.display_name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Subscribes to this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').subscribe()\n    */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      return this._setSubscribed(true);\n    }\n    /**\n    * @summary Unsubscribes from this subreddit.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').unsubscribe()\n    */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this7 = this;\n      /* Reddit returns a 404 error if the user attempts to unsubscribe to a subreddit that they weren't subscribed to in the\n      first place. It also (as one would expect) returns a 404 error if the subreddit in question does not exist. snoowrap\n      should swallow the first type of error internally, but it should raise the second type of error. Unfortunately, the errors\n      themselves are indistinguishable. So if a 404 error gets thrown, fetch the current subreddit to check if it exists. If it\n      does exist, then the 404 error was of the first type, so swallow it and return the current Subreddit object as usual. If\n      the subreddit doesn't exist, then the original error was of the second type, so throw it. */\n\n\n      return this._setSubscribed(false).catch({\n        statusCode: 404\n      }, function (err) {\n        return _this7.fetch().return(_this7).catchThrow(err);\n      });\n    }\n  }, {\n    key: \"_uploadSrImg\",\n    value: function _uploadSrImg(_ref9) {\n      var _this8 = this;\n\n      var name = _ref9.name,\n          file = _ref9.file,\n          uploadType = _ref9.uploadType,\n          imageType = _ref9.imageType;\n\n      if (typeof file !== 'string' && !(file instanceof _stream.Readable)) {\n        throw new _errors.InvalidMethodCallError('Uploaded image filepath must be a string or a ReadableStream.');\n      }\n\n      var parsedFile = typeof file === 'string' ? (0, _fs.createReadStream)(file) : file;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/upload_sr_img',\n        formData: {\n          name: name,\n          upload_type: uploadType,\n          img_type: imageType,\n          file: parsedFile\n        }\n      }).then(function (result) {\n        if (result.errors.length) {\n          throw result.errors[0];\n        }\n\n        return _this8;\n      });\n    }\n    /**\n    * @summary Uploads an image for use in this subreddit's stylesheet.\n    * @param {object} options\n    * @param {string} options.name The name that the new image should have in the stylesheet\n    * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n    image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) in environments (e.g.\n    browsers) where the filesystem is unavailable.\n    * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').uploadSubredditImage({name: 'the cookie monster', file: './cookie_monster.png'})\n    */\n\n  }, {\n    key: \"uploadStylesheetImage\",\n    value: function uploadStylesheetImage(_ref10) {\n      var name = _ref10.name,\n          file = _ref10.file,\n          _ref10$image_type = _ref10.image_type,\n          image_type = _ref10$image_type === undefined ? 'png' : _ref10$image_type,\n          _ref10$imageType = _ref10.imageType,\n          imageType = _ref10$imageType === undefined ? image_type : _ref10$imageType;\n      return this._uploadSrImg({\n        name: name,\n        file: file,\n        imageType: imageType,\n        uploadType: 'img'\n      });\n    }\n    /**\n    * @summary Uploads an image to use as this subreddit's header.\n    * @param {object} options\n    * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n    image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n    browsers) where the filesystem is unavailable.\n    * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').uploadHeaderImage({name: 'the cookie monster', file: './cookie_monster.png'})\n    */\n\n  }, {\n    key: \"uploadHeaderImage\",\n    value: function uploadHeaderImage(_ref11) {\n      var file = _ref11.file,\n          _ref11$image_type = _ref11.image_type,\n          image_type = _ref11$image_type === undefined ? 'png' : _ref11$image_type,\n          _ref11$imageType = _ref11.imageType,\n          imageType = _ref11$imageType === undefined ? image_type : _ref11$imageType;\n      return this._uploadSrImg({\n        file: file,\n        imageType: imageType,\n        uploadType: 'header'\n      });\n    }\n    /**\n    * @summary Uploads an image to use as this subreddit's mobile icon.\n    * @param {object} options\n    * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n    image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n    browsers) where the filesystem is unavailable.\n    * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').uploadIcon({name: 'the cookie monster', file: './cookie_monster.png'})\n    */\n\n  }, {\n    key: \"uploadIcon\",\n    value: function uploadIcon(_ref12) {\n      var file = _ref12.file,\n          _ref12$image_type = _ref12.image_type,\n          image_type = _ref12$image_type === undefined ? 'png' : _ref12$image_type,\n          _ref12$imageType = _ref12.imageType,\n          imageType = _ref12$imageType === undefined ? image_type : _ref12$imageType;\n      return this._uploadSrImg({\n        file: file,\n        imageType: imageType,\n        uploadType: 'icon'\n      });\n    }\n    /**\n    * @summary Uploads an image to use as this subreddit's mobile banner.\n    * @param {object} options\n    * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n    image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n    browsers) where the filesystem is unavailable.\n    * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n    * @example r.getSubreddit('snoowrap').uploadBannerImage({name: 'the cookie monster', file: './cookie_monster.png'})\n    */\n\n  }, {\n    key: \"uploadBannerImage\",\n    value: function uploadBannerImage(_ref13) {\n      var file = _ref13.file,\n          _ref13$image_type = _ref13.image_type,\n          image_type = _ref13$image_type === undefined ? 'png' : _ref13$image_type,\n          _ref13$imageType = _ref13.imageType,\n          imageType = _ref13$imageType === undefined ? image_type : _ref13$imageType;\n      return this._uploadSrImg({\n        file: file,\n        imageType: imageType,\n        upload_type: 'banner'\n      });\n    }\n    /**\n    * @summary Gets information on this subreddit's rules.\n    * @returns {Promise} A Promise that fulfills with information on this subreddit's rules.\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getRules().then(console.log)\n    *\n    * // => {\n    *   rules: [\n    *     {\n    *       kind: 'all',\n    *       short_name: 'Rule 1: No violating rule 1',\n    *       description: 'Breaking this rule is not allowed.',\n    *       ...\n    *     },\n    *     ...\n    *   ],\n    *   site_rules: [\n    *     'Spam',\n    *     'Personal and confidential information'',\n    *     'Threatening, harassing, or inciting violence'\n    *   ]\n    * }\n    */\n\n  }, {\n    key: \"getRules\",\n    value: function getRules() {\n      return this._get({\n        uri: 'r/' + this.display_name + '/about/rules'\n      });\n    }\n    /**\n    * @summary Gets the stickied post on this subreddit, or throws a 404 error if none exists.\n    * @param {object} [options]\n    * @param {number} [options.num=1] The number of the sticky to get. Should be either `1` (first sticky) or `2` (second sticky).\n    * @returns {Promise} A Submission object representing this subreddit's stickied submission\n    * @example\n    * r.getSubreddit('snoowrap').getSticky({num: 2})\n    * // => Submission { ... }\n    */\n\n  }, {\n    key: \"getSticky\",\n    value: function getSticky() {\n      var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref14$num = _ref14.num,\n          num = _ref14$num === undefined ? 1 : _ref14$num;\n\n      return this._get({\n        uri: 'r/' + this.display_name + '/about/sticky',\n        qs: {\n          num: num\n        }\n      });\n    }\n  }, {\n    key: \"_friend\",\n    value: function _friend(options) {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/friend',\n        form: _extends({}, options, {\n          api_type: api_type\n        })\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n  }, {\n    key: \"_unfriend\",\n    value: function _unfriend(options) {\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/unfriend',\n        form: _extends({}, options, {\n          api_type: api_type\n        })\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Invites the given user to be a moderator of this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be invited\n    * @param {Array} [options.permissions] The moderator permissions that this user should have. This should be an array\n    containing some combination of `\"wiki\", \"posts\", \"access\", \"mail\", \"config\", \"flair\"`. To add a moderator with full\n    permissions, omit this property entirely.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').inviteModerator({name: 'actually_an_aardvark', permissions: ['posts', 'wiki']})\n    */\n\n  }, {\n    key: \"inviteModerator\",\n    value: function inviteModerator(_ref15) {\n      var name = _ref15.name,\n          permissions = _ref15.permissions;\n      return this._friend({\n        name: name,\n        permissions: (0, _helpers.formatModPermissions)(permissions),\n        type: 'moderator_invite'\n      });\n    }\n    /**\n    * @summary Revokes an invitation for the given user to be a moderator.\n    * @param {object} options\n    * @param {string} options.name The username of the account whose invitation should be revoked\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').revokeModeratorInvite({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"revokeModeratorInvite\",\n    value: function revokeModeratorInvite(_ref16) {\n      var name = _ref16.name;\n      return this._unfriend({\n        name: name,\n        type: 'moderator_invite'\n      });\n    }\n    /**\n    * @summary Removes the given user's moderator status on this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account whose moderator status should be removed\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').removeModerator({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"removeModerator\",\n    value: function removeModerator(_ref17) {\n      var name = _ref17.name;\n      return this._unfriend({\n        name: name,\n        type: 'moderator'\n      });\n    }\n    /**\n    * @summary Makes the given user an approved submitter of this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be given this status\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').addContributor({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"addContributor\",\n    value: function addContributor(_ref18) {\n      var name = _ref18.name;\n      return this._friend({\n        name: name,\n        type: 'contributor'\n      });\n    }\n    /**\n    * @summary Revokes this user's approved submitter status on this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account whose status should be revoked\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').removeContributor({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"removeContributor\",\n    value: function removeContributor(_ref19) {\n      var name = _ref19.name;\n      return this._unfriend({\n        name: name,\n        type: 'contributor'\n      });\n    }\n    /**\n    * @summary Bans the given user from this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be banned\n    * @param {string} [options.banMessage] The ban message. This will get sent to the user in a private message, alerting them\n    that they have been banned.\n    * @param {string} [options.banReason] A string indicating which rule the banned user broke (100 characters max)\n    * @param {number} [options.duration] The duration of the ban, in days. For a permanent ban, omit this parameter.\n    * @param {string} [options.banNote] A note that appears on the moderation log, usually used to indicate the reason for the\n    ban. This is not visible to the banned user. (300 characters max)\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').banUser({name: 'actually_an_aardvark', banMessage: 'You are now banned LOL'})\n    */\n\n  }, {\n    key: \"banUser\",\n    value: function banUser(_ref20) {\n      var name = _ref20.name,\n          ban_message = _ref20.ban_message,\n          _ref20$banMessage = _ref20.banMessage,\n          banMessage = _ref20$banMessage === undefined ? ban_message : _ref20$banMessage,\n          ban_reason = _ref20.ban_reason,\n          _ref20$banReason = _ref20.banReason,\n          banReason = _ref20$banReason === undefined ? ban_reason : _ref20$banReason,\n          duration = _ref20.duration,\n          ban_note = _ref20.ban_note,\n          _ref20$banNote = _ref20.banNote,\n          banNote = _ref20$banNote === undefined ? ban_note : _ref20$banNote;\n      return this._friend({\n        name: name,\n        ban_message: banMessage,\n        ban_reason: banReason,\n        duration: duration,\n        note: banNote,\n        type: 'banned'\n      });\n    }\n    /**\n    * @summary Unbans the given user from this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be unbanned\n    * @returns {Promise} A Promise that fulfills when the request is complete\n    * @example r.getSubreddit('snoowrap').unbanUser({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"unbanUser\",\n    value: function unbanUser(_ref21) {\n      var name = _ref21.name;\n      return this._unfriend({\n        name: name,\n        type: 'banned'\n      });\n    }\n    /**\n    * @summary Mutes the given user from messaging this subreddit for 72 hours.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be muted\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').muteUser({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"muteUser\",\n    value: function muteUser(_ref22) {\n      var name = _ref22.name;\n      return this._friend({\n        name: name,\n        type: 'muted'\n      });\n    }\n    /**\n    * @summary Unmutes the given user from messaging this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be muted\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').unmuteUser({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"unmuteUser\",\n    value: function unmuteUser(_ref23) {\n      var name = _ref23.name;\n      return this._unfriend({\n        name: name,\n        type: 'muted'\n      });\n    }\n    /**\n    * @summary Bans the given user from editing this subreddit's wiki.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be wikibanned\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').wikibanUser({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"wikibanUser\",\n    value: function wikibanUser(_ref24) {\n      var name = _ref24.name;\n      return this._friend({\n        name: name,\n        type: 'wikibanned'\n      });\n    }\n    /**\n    * @summary Unbans the given user from editing this subreddit's wiki.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be unwikibanned\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').unwikibanUser({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"unwikibanUser\",\n    value: function unwikibanUser(_ref25) {\n      var name = _ref25.name;\n      return this._unfriend({\n        name: name,\n        type: 'wikibanned'\n      });\n    }\n    /**\n    * @summary Adds the given user to this subreddit's list of approved wiki editors.\n    * @param {object} options\n    * @param {string} options.name The username of the account that should be given approved editor status\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').addWikiContributor({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"addWikiContributor\",\n    value: function addWikiContributor(_ref26) {\n      var name = _ref26.name;\n      return this._friend({\n        name: name,\n        type: 'wikicontributor'\n      });\n    }\n    /**\n    * @summary Removes the given user from this subreddit's list of approved wiki editors.\n    * @param {object} options\n    * @param {string} options.name The username of the account whose approved editor status should be revoked\n    * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n    * @example r.getSubreddit('snoowrap').removeWikiContributor({name: 'actually_an_aardvark'})\n    */\n\n  }, {\n    key: \"removeWikiContributor\",\n    value: function removeWikiContributor(_ref27) {\n      var name = _ref27.name;\n      return this._unfriend({\n        name: name,\n        type: 'wikicontributor'\n      });\n    }\n    /**\n    * @summary Sets the permissions for a given moderator on this subreddit.\n    * @param {object} options\n    * @param {string} options.name The username of the moderator whose permissions are being changed\n    * @param {Array} [options.permissions] The new moderator permissions that this user should have. This should be an array\n    containing some combination of `\"wiki\", \"posts\", \"access\", \"mail\", \"config\", \"flair\"`. To add a moderator with full\n    permissions, omit this property entirely.\n    * @returns {Promise} A Promise that fulfills with this Subreddit when this request is complete\n    * @example r.getSubreddit('snoowrap').setModeratorPermissions({name: 'actually_an_aardvark', permissions: ['mail']})\n    */\n\n  }, {\n    key: \"setModeratorPermissions\",\n    value: function setModeratorPermissions(_ref28) {\n      var name = _ref28.name,\n          permissions = _ref28.permissions;\n      return this._post({\n        uri: 'r/' + this.display_name + '/api/setpermissions',\n        form: {\n          api_type: api_type,\n          name: name,\n          permissions: (0, _helpers.formatModPermissions)(permissions),\n          type: 'moderator'\n        }\n      }).then((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Gets a given wiki page on this subreddit.\n    * @param {string} title The title of the desired wiki page.\n    * @returns {WikiPage} An unfetched WikiPage object corresponding to the desired wiki page\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getWikiPage('index')\n    * // => WikiPage { title: 'index', subreddit: Subreddit { display_name: 'snoowrap' } }\n    */\n\n  }, {\n    key: \"getWikiPage\",\n    value: function getWikiPage(title) {\n      return this._r._newObject('WikiPage', {\n        subreddit: this,\n        title: title\n      });\n    }\n    /**\n    * @summary Gets the list of wiki pages on this subreddit.\n    * @returns {Promise} An Array containing WikiPage objects\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getWikiPages().then(console.log)\n    * // => [\n    * //   WikiPage { title: 'index', subreddit: Subreddit { display_name: 'snoowrap'} }\n    * //   WikiPage { title: 'config/sidebar', subreddit: Subreddit { display_name: 'snoowrap'} }\n    * //   WikiPage { title: 'secret_things', subreddit: Subreddit { display_name: 'snoowrap'} }\n    * //   WikiPage { title: 'config/submit_text', subreddit: Subreddit { display_name: 'snoowrap'} }\n    * // ]\n    */\n\n  }, {\n    key: \"getWikiPages\",\n    value: function getWikiPages() {\n      var _this9 = this;\n\n      return this._get({\n        uri: 'r/' + this.display_name + '/wiki/pages'\n      }).map(function (title) {\n        return _this9.getWikiPage(title);\n      });\n    }\n    /**\n    * @summary Gets a list of revisions on this subreddit's wiki.\n    * @param {object} [options] Options for the resulting Listing\n    * @returns {Promise} A Listing containing wiki revisions\n    * @example\n    *\n    * r.getSubreddit('snoowrap').getWikiRevisions().then(console.log)\n    * // => Listing [\n    * //  { page: 'index', reason: 'added cookies', ... },\n    * //  ...\n    * // ]\n    */\n\n  }, {\n    key: \"getWikiRevisions\",\n    value: function getWikiRevisions(options) {\n      return this._getListing({\n        uri: 'r/' + this.display_name + '/wiki/revisions',\n        qs: options\n      });\n    }\n  }, {\n    key: \"_uri\",\n    get: function get() {\n      return 'r/' + this.display_name + '/about';\n    }\n  }]);\n\n  return Subreddit;\n}(_RedditContent2.default);\n\nexports.default = Subreddit;","map":null,"metadata":{},"sourceType":"script"}