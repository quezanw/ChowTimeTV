{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.emptyChildren = undefined;\n\nvar _remove2 = require('lodash/remove');\n\nvar _remove3 = _interopRequireDefault(_remove2);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _forEach2 = require('lodash/forEach');\n\nvar _forEach3 = _interopRequireDefault(_forEach2);\n\nvar _flatten2 = require('lodash/flatten');\n\nvar _flatten3 = _interopRequireDefault(_flatten2);\n\nvar _concat2 = require('lodash/concat');\n\nvar _concat3 = _interopRequireDefault(_concat2);\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _Promise = require('../Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _helpers = require('../helpers.js');\n\nvar _constants = require('../constants.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar api_type = 'json';\n/**\n* The `More` class is a helper representing reddit's exposed `more` type in comment threads, used to fetch additional comments\non a thread.\n* No instances of the `More` class are exposed externally by snoowrap; instead, comment lists are exposed as Listings.\nAdditional replies on an item can be fetched by calling `fetchMore` on a Listing, in the same manner as what would be done\nwith a Listing of posts. snoowrap should handle the differences internally, and expose a nearly-identical interface for the\ntwo use-cases.\n\nCombining reddit's `Listing` and `more` objects has the advantage of having a more consistent exposed interface; for example,\nif a consumer iterates over the comments on a Submission, all of the iterated items will actually be Comment objects, so the\nconsumer won't encounter an unexpected `more` object at the end. However, there are a few disadvantages, namely that (a) this\nleads to an increase in internal complexity, and (b) there are a few cases where reddit's `more` objects have different amounts\nof available information (e.g. all the child IDs of a `more` object are known on creation), which leads to different optimal\nbehavior.\n*/\n\nvar More =\n/*#__PURE__*/\nfunction () {\n  function More(options, _r) {\n    _classCallCheck(this, More);\n\n    Object.assign(this, options);\n    this._r = _r;\n  }\n  /* Requests to /api/morechildren are capped at 20 comments at a time, but requests to /api/info are capped at 100, so\n  it's easier to send to the latter. The disadvantage is that comment replies are not automatically sent from requests\n  to /api/info. */\n\n\n  _createClass(More, [{\n    key: \"fetchMore\",\n    value: function fetchMore(options) {\n      var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (options.amount <= 0 || startIndex >= this.children.length) {\n        return _Promise2.default.resolve([]);\n      }\n\n      if (!options.skipReplies) {\n        return this.fetchTree(options, startIndex);\n      }\n\n      var ids = getNextIdSlice(this.children, startIndex, options.amount, _constants.MAX_API_INFO_AMOUNT).map(function (id) {\n        return 't1_' + id;\n      }); // Requests are capped at 100 comments. Send lots of requests recursively to get the comments, then concatenate them.\n      // (This speed-requesting is only possible with comment Listings since the entire list of ids is present initially.)\n\n      var promiseForThisBatch = this._r._getListing({\n        uri: 'api/info',\n        qs: {\n          id: ids.join(',')\n        }\n      });\n\n      var nextRequestOptions = _extends({}, options, {\n        amount: options.amount - ids.length\n      });\n\n      var promiseForRemainingItems = this.fetchMore(nextRequestOptions, startIndex + ids.length);\n      return _Promise2.default.all([promiseForThisBatch, promiseForRemainingItems]).then(_flatten3.default);\n    }\n  }, {\n    key: \"fetchTree\",\n    value: function fetchTree(options, startIndex) {\n      var _this = this;\n\n      if (options.amount <= 0 || startIndex >= this.children.length) {\n        return _Promise2.default.resolve([]);\n      }\n\n      var ids = getNextIdSlice(this.children, startIndex, options.amount, _constants.MAX_API_MORECHILDREN_AMOUNT);\n      return this._r._get({\n        uri: 'api/morechildren',\n        qs: {\n          api_type: api_type,\n          children: ids.join(','),\n          link_id: this.link_id || this.parent_id\n        }\n      }).tap(_helpers.handleJsonErrors).then(function (res) {\n        return res.json.data.things;\n      }).map(_helpers.addEmptyRepliesListing).then(_helpers.buildRepliesTree).then(function (resultTrees) {\n        /* Sometimes, when sending a request to reddit to get multiple comments from a `more` object, reddit decides to only\n        send some of the requested comments, and then stub out the remaining ones in a smaller `more` object. ( ¯\\_(ツ)_/¯ )\n        In these cases, recursively fetch the smaller `more` objects as well. */\n        var childMores = (0, _remove3.default)(resultTrees, function (c) {\n          return c instanceof More;\n        });\n        (0, _forEach3.default)(childMores, function (c) {\n          c.link_id = _this.link_id || _this.parent_id;\n        });\n        return _Promise2.default.mapSeries(childMores, function (c) {\n          return c.fetchTree(_extends({}, options, {\n            amount: Infinity\n          }), 0);\n        }).then(function (expandedTrees) {\n          return _this.fetchMore(_extends({}, options, {\n            amount: options.amount - ids.length\n          }), startIndex + ids.length).then(function (nexts) {\n            return (0, _concat3.default)(resultTrees, (0, _flatten3.default)(expandedTrees), nexts);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      return new More((0, _pick3.default)(this, Object.getOwnPropertyNames(this)), this._r);\n    }\n  }]);\n\n  return More;\n}();\n\nfunction getNextIdSlice(children, startIndex, desiredAmount, limit) {\n  return children.slice(startIndex, startIndex + Math.min(desiredAmount, limit));\n}\n\nvar emptyChildren = exports.emptyChildren = new More({\n  children: []\n});\nexports.default = More;","map":null,"metadata":{},"sourceType":"script"}