{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _mapValues2 = require('lodash/mapValues');\n\nvar _mapValues3 = _interopRequireDefault(_mapValues2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _Promise = require('../Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _helpers = require('../helpers.js');\n\nvar _constants = require('../constants.js');\n\nvar _Listing = require('./Listing.js');\n\nvar _Listing2 = _interopRequireDefault(_Listing);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* A base class for content from reddit. With the expection of Listings, all content types extend this class.\n* This class should be considered 'abstract', to the extend that JavaScript classes can be -- it should not be necessary to\n* instantiate it directly.\n* <style> #RedditContent {display: none} </style>\n*/\n\n\nvar RedditContent =\n/*#__PURE__*/\nfunction () {\n  function RedditContent(options, _r, _hasFetched) {\n    _classCallCheck(this, RedditContent);\n\n    // _r refers to the snoowrap requester that is used to fetch this content.\n    this._r = _r;\n    this._fetch = null;\n    this._hasFetched = !!_hasFetched;\n    Object.assign(this, options);\n\n    if (typeof Proxy !== 'undefined' && !this._hasFetched && _r._config.proxies) {\n      return new Proxy(this, {\n        get: function get(target, key) {\n          return key in target || key === 'length' || key in _Promise2.default.prototype ? target[key] : target.fetch()[key];\n        }\n      });\n    }\n  }\n  /**\n  * @summary Fetches this content from reddit.\n  * @desc This will not mutate the original content object; all Promise properties will remain as Promises after the content has\n  * been fetched. However, the information on this object will be cached, so it may become out-of-date with the content on\n  * reddit. To clear the cache and fetch this object from reddit again, use `refresh()`.\n  *\n  * If snoowrap is running in an environment that supports ES2015 Proxies (e.g. Chrome 49+), then `fetch()` will get\n  * automatically called when an unknown property is accessed on an unfetched content object.\n  * @returns {Promise} A version of this object with all of its fetched properties from reddit. This will not mutate the\n  object. Once an object has been fetched once, its properties will be cached, so they might end up out-of-date if this\n  function is called again. To refresh an object, use refresh().\n  * @example\n  *\n  * r.getUser('not_an_aardvark').fetch().then(userInfo => {\n  *   console.log(userInfo.name); // 'not_an_aardvark'\n  *   console.log(userInfo.created_utc); // 1419104352\n  * });\n  *\n  * r.getComment('d1xchqn').fetch().then(comment => comment.body).then(console.log)\n  * // => 'This is a little too interesting for my liking'\n  *\n  * // In environments that support ES2015 Proxies, the above line is equivalent to:\n  * r.getComment('d1xchqn').body.then(console.log);\n  * // => 'This is a little too interesting for my liking'\n  */\n\n\n  _createClass(RedditContent, [{\n    key: \"fetch\",\n    value: function fetch() {\n      var _this = this;\n\n      if (!this._fetch) {\n        this._fetch = this._r._promiseWrap(this._r._get({\n          uri: this._uri\n        }).then(function (res) {\n          return _this._transformApiResponse(res);\n        }));\n      }\n\n      return this._fetch;\n    }\n    /**\n    * @summary Refreshes this content.\n    * @returns {Promise} A newly-fetched version of this content\n    * @example\n    *\n    * var someComment = r.getComment('cmfkyus');\n    * var initialCommentBody = some_comment.fetch().then(comment => comment.body);\n    *\n    * setTimeout(() => {\n    *   someComment.refresh().then(refreshedComment => {\n    *     if (initialCommentBody.value() !== refreshedComment.body) {\n    *       console.log('This comment has changed since 10 seconds ago.');\n    *     }\n    *   });\n    * }, 10000);\n    */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this._fetch = null;\n      return this.fetch();\n    }\n    /**\n    * @summary Returns a stringifyable version of this object.\n    * @desc It is usually not necessary to call this method directly; simply running JSON.stringify(some_object) will strip the\n    private properties anyway.\n    * @returns {object} A version of this object with all the private properties stripped\n    * @example\n    *\n    * var user = r.getUser('not_an_aardvark');\n    * JSON.stringify(user) // => '{\"name\":\"not_an_aardvark\"}'\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return (0, _mapValues3.default)(this._stripPrivateProps(), function (value, key) {\n        if (value instanceof RedditContent && !value._hasFetched) {\n          if (value.constructor._name === 'RedditUser' && _constants.USER_KEYS.has(key)) {\n            return value.name;\n          }\n\n          if (value.constructor._name === 'Subreddit' && _constants.SUBREDDIT_KEYS.has(key)) {\n            return value.display_name;\n          }\n        }\n\n        return value && value.toJSON ? value.toJSON() : value;\n      });\n    }\n  }, {\n    key: \"_stripPrivateProps\",\n    value: function _stripPrivateProps() {\n      return (0, _pick3.default)(this, Object.keys(this).filter(function (key) {\n        return !key.startsWith('_');\n      }));\n    }\n  }, {\n    key: \"_transformApiResponse\",\n    value: function _transformApiResponse(response) {\n      return response;\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$deep = _ref.deep,\n          deep = _ref$deep === undefined ? false : _ref$deep;\n\n      var clonedProps = (0, _mapValues3.default)(this, function (value) {\n        if (deep) {\n          return value instanceof RedditContent || value instanceof _Listing2.default ? value._clone({\n            deep: deep\n          }) : (0, _cloneDeep3.default)(value);\n        }\n\n        return value;\n      });\n      return this._r._newObject(this.constructor._name, clonedProps, this._hasFetched);\n    }\n  }, {\n    key: \"_getListing\",\n    value: function _getListing() {\n      var _r2;\n\n      return (_r2 = this._r)._getListing.apply(_r2, arguments);\n    }\n  }]);\n\n  return RedditContent;\n}();\n\n(0, _helpers.defineInspectFunc)(RedditContent.prototype, function () {\n  return this.constructor._name + ' ' + _util2.default.inspect(this._stripPrivateProps());\n});\n\n_constants.HTTP_VERBS.forEach(function (method) {\n  Object.defineProperty(RedditContent.prototype, '_' + method, {\n    value: function value() {\n      var _r3;\n\n      return (_r3 = this._r)['_' + method].apply(_r3, arguments);\n    },\n    configurable: true,\n    writable: true\n  });\n});\n\nexports.default = RedditContent;","map":null,"metadata":{},"sourceType":"script"}