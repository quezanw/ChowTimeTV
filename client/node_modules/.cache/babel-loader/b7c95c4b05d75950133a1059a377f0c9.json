{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/quezan/Desktop/ChowTimeTV/client/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Promise = require('../Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _helpers = require('../helpers.js');\n\nvar _ReplyableContent = require('./ReplyableContent.js');\n\nvar _ReplyableContent2 = _interopRequireDefault(_ReplyableContent);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar api_type = 'json';\n/**\n* A set of mixin functions that apply to Submissions and Comments.\n* <style> #VoteableContent {display: none} </style>\n* @extends ReplyableContent\n*/\n\nvar VoteableContent =\n/*#__PURE__*/\nfunction (_ReplyableContent2$de) {\n  _inherits(VoteableContent, _ReplyableContent2$de);\n\n  function VoteableContent() {\n    _classCallCheck(this, VoteableContent);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VoteableContent).apply(this, arguments));\n  }\n\n  _createClass(VoteableContent, [{\n    key: \"_vote\",\n\n    /**\n    * @summary Casts a vote on this Comment or Submission.\n    * @private\n    * @param {number} direction The direction of the vote. (1 for an upvote, -1 for a downvote, 0 to remove a vote)\n    * @returns {Promise} A Promise that fulfills when the request is complete.\n    */\n    value: function _vote(direction) {\n      return this._post({\n        uri: 'api/vote',\n        form: {\n          dir: direction,\n          id: this.name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Upvotes this Comment or Submission.\n    * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete\n    * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK,\n    but bots deciding how to vote on content or amplifying a human's vote are not. See the\n    [reddit rules](https://reddit.com/rules) for more details on what constitutes vote cheating. (This guideline is quoted from\n    [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n    * @example r.getSubmission('4e62ml').upvote()\n    */\n\n  }, {\n    key: \"upvote\",\n    value: function upvote() {\n      return this._vote(1);\n    }\n    /**\n    * @summary Downvotes this Comment or Submission.\n    * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete.\n    * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK, but\n    bots deciding how to vote on content or amplifying a human's vote are not. See the [reddit rules](https://reddit.com/rules)\n    for more details on what constitutes vote cheating. (This guideline is quoted from\n    [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n    * @example r.getSubmission('4e62ml').downvote()\n    */\n\n  }, {\n    key: \"downvote\",\n    value: function downvote() {\n      return this._vote(-1);\n    }\n    /**\n    * @summary Removes any existing vote on this Comment or Submission.\n    * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete.\n    * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK, but\n    bots deciding how to vote on content or amplifying a human's vote are not. See the [reddit rules](https://reddit.com/rules)\n    for more details on what constitutes vote cheating. (This guideline is quoted from\n    [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n    * @example r.getSubmission('4e62ml').unvote()\n    */\n\n  }, {\n    key: \"unvote\",\n    value: function unvote() {\n      return this._vote(0);\n    }\n    /**\n    * @summary Saves this Comment or Submission (i.e. adds it to the list at reddit.com/saved)\n    * @returns {Promise} A Promise that fulfills when the request is complete\n    * @example r.getSubmission('4e62ml').save()\n    */\n\n  }, {\n    key: \"save\",\n    value: function save() {\n      return this._post({\n        uri: 'api/save',\n        form: {\n          id: this.name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Unsaves this item\n    * @returns {Promise} A Promise that fulfills when the request is complete\n    * @example r.getSubmission('4e62ml').unsave()\n    */\n\n  }, {\n    key: \"unsave\",\n    value: function unsave() {\n      return this._post({\n        uri: 'api/unsave',\n        form: {\n          id: this.name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Distinguishes this Comment or Submission with a sigil.\n    * @desc **Note:** This function will only work if the requester is the author of this Comment/Submission.\n    * @param {object} options\n    * @param {boolean|string} [options.status=true] Determines how the item should be distinguished.\n    `true` (default) signifies that the item should be moderator-distinguished, and\n    `false` signifies that the item should not be distinguished. Passing a string (e.g.\n    `admin`) will cause the item to get distinguished with that string, if possible.\n    * @param {boolean} [options.sticky=false] Determines whether this item should be stickied in addition to being\n    distinguished. (This only applies to comments; to sticky a submission, use {@link Submission#sticky} instead.)\n    * @returns {Promise} A Promise that fulfills when the request is complete.\n    * @example r.getComment('d1xclfo').distinguish({status: true, sticky: true})\n    */\n\n  }, {\n    key: \"distinguish\",\n    value: function distinguish() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$status = _ref.status,\n          status = _ref$status === undefined ? true : _ref$status,\n          _ref$sticky = _ref.sticky,\n          sticky = _ref$sticky === undefined ? false : _ref$sticky;\n\n      return this._post({\n        uri: 'api/distinguish',\n        form: {\n          api_type: api_type,\n          how: status === true ? 'yes' : status === false ? 'no' : status,\n          sticky: sticky,\n          id: this.name\n        }\n      }).return(this);\n    }\n    /**\n    * @summary Undistinguishes this Comment or Submission. Alias for distinguish({status: false})\n    * @returns {Promise} A Promise that fulfills when the request is complete.\n    * @example r.getSubmission('4e62ml').undistinguish()\n    */\n\n  }, {\n    key: \"undistinguish\",\n    value: function undistinguish() {\n      return this.distinguish({\n        status: false,\n        sticky: false\n      }).return(this);\n    }\n    /**\n    * @summary Edits this Comment or Submission.\n    * @param {string} updatedText The updated markdown text to use\n    * @returns {Promise} A Promise that fulfills when this request is complete.\n    * @example r.getComment('coip909').edit('Blah blah blah this is new updated text')\n    */\n\n  }, {\n    key: \"edit\",\n    value: function edit(updatedText) {\n      return this._post({\n        uri: 'api/editusertext',\n        form: {\n          api_type: api_type,\n          text: updatedText,\n          thing_id: this.name\n        }\n      }).tap((0, _helpers.handleJsonErrors)(this));\n    }\n    /**\n    * @summary Gives reddit gold to the author of this Comment or Submission.\n    * @returns {Promise} A Promise that fullfills with this Comment/Submission when this request is complete\n    * @example r.getComment('coip909').gild()\n    */\n\n  }, {\n    key: \"gild\",\n    value: function gild() {\n      return this._post({\n        uri: 'api/v1/gold/gild/' + this.name\n      }).return(this);\n    }\n  }, {\n    key: \"_setInboxRepliesEnabled\",\n    value: function _setInboxRepliesEnabled(state) {\n      return this._post({\n        uri: 'api/sendreplies',\n        form: {\n          state: state,\n          id: this.name\n        }\n      });\n    }\n    /**\n    * @summary Enables inbox replies on this Comment or Submission\n    * @returns {Promise} A Promise that fulfills with this content when the request is complete\n    * @example r.getComment('coip909').enableInboxReplies()\n    */\n\n  }, {\n    key: \"enableInboxReplies\",\n    value: function enableInboxReplies() {\n      return this._setInboxRepliesEnabled(true).return(this);\n    }\n    /**\n    * @summary Disables inbox replies on this Comment or Submission\n    * @returns {Promise} A Promise that fulfills with this content when the request is complete\n    * @example r.getComment('coip909').disableInboxReplies()\n    */\n\n  }, {\n    key: \"disableInboxReplies\",\n    value: function disableInboxReplies() {\n      return this._setInboxRepliesEnabled(false).return(this);\n    }\n  }, {\n    key: \"_mutateAndExpandReplies\",\n    value: function _mutateAndExpandReplies(_ref2) {\n      var _this = this;\n\n      var limit = _ref2.limit,\n          depth = _ref2.depth;\n\n      if (depth <= 0) {\n        return _Promise2.default.resolve(this);\n      }\n\n      var repliesKey = this.constructor._name === 'Submission' ? 'comments' : 'replies';\n      return this[repliesKey].fetchMore({\n        amount: limit - this[repliesKey].length\n      }).tap(function (replies) {\n        _this[repliesKey] = replies;\n      }).then(function (replies) {\n        return replies.slice(0, limit);\n      }).map(function (reply) {\n        return reply._mutateAndExpandReplies({\n          limit: limit,\n          depth: depth - 1\n        });\n      }).return(this);\n    }\n    /**\n    * @summary Expands the reply Listings on this Comment/Submission.\n    * @desc This is useful in cases where one wants to enumerate all comments on a\n    thread, even the ones that are initially hidden when viewing it (e.g. long comment chains).\n    *\n    * This function accepts two optional parameters `options.limit` and `options.depth`. `options.limit` sets an upper bound\n    for the branching factor of the resulting replies tree, i.e. the number of comments that are fetched in reply to any given\n    item. `options.depth` sets an upper bound for the depth of the resulting replies tree (where a depth of 0 signifies that no\n    replies should be fetched at all).\n    *\n    * Note that regardless of the `limit` and `depth` parameters used, any reply that appeared in the original reply tree will\n    appear in the expanded reply tree. In certain cases, the depth of the resulting tree may also be larger than `options.depth`,\n    if the reddit API returns more of a comment tree than needed.\n    *\n    * These parameters should primarily be used to keep the request count low; if a precise limit and depth are needed, it is\n    recommended to manually verify the comments in the tree afterwards.\n    *\n    * Both parameters default to `Infinity` if omitted, i.e. the resulting tree contains every single comment available. It should\n    be noted that depending on the size and depth of the thread, fetching every single comment can use up a significant number\n    of ratelimited requests. (To give an intuitive estimate, consider how many clicks would be needed to view all the\n    comments on the thread using the HTML site.)\n    * @param {object} [options={}]\n    * @param {number} [options.limit=Infinity] An upper-bound for the branching factor of the resulting tree of replies\n    * @param {number} [options.depth=Infinity] An upper-bound for the depth of the resulting tree of replies\n    * @returns {Promise} A Promise that fulfills with a new version of this object that has an expanded reply tree. The original\n    object is not modified\n    * @example r.getSubmission('4fuq26').expandReplies().then(console.log)\n    * // => (a very large comment tree containing every viewable comment on this thread)\n    */\n\n  }, {\n    key: \"expandReplies\",\n    value: function expandReplies() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$limit = _ref3.limit,\n          limit = _ref3$limit === undefined ? Infinity : _ref3$limit,\n          _ref3$depth = _ref3.depth,\n          depth = _ref3$depth === undefined ? Infinity : _ref3$depth;\n\n      return this._r._promiseWrap(this.fetch().then(function (result) {\n        return result._clone({\n          deep: true\n        })._mutateAndExpandReplies({\n          limit: limit,\n          depth: depth\n        });\n      }));\n    }\n  }]);\n\n  return VoteableContent;\n}(_ReplyableContent2.default); // VoteableContent#delete is not in the class body since Safari 9 can't parse the `delete` function name in class bodies.\n\n/**\n* @function\n* @name delete\n* @summary Deletes this Comment or Submission\n* @returns {Promise} A Promise that fulfills with this Comment/Submission when this request is complete\n* @example r.getComment('coip909').delete()\n* @memberof VoteableContent\n* @instance\n*/\n\n\nObject.defineProperty(VoteableContent.prototype, 'delete', {\n  value: function value() {\n    return this._post({\n      uri: 'api/del',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  },\n  configurable: true,\n  writable: true\n});\nexports.default = VoteableContent;","map":null,"metadata":{},"sourceType":"script"}