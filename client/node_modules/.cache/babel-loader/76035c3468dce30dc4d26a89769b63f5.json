{"ast":null,"code":"'use strict';\n\nvar handlers;\n\nvar wrap = function wrap(target) {\n  if (typeof target === 'object' && target && typeof target.then === 'function' && typeof Proxy !== 'undefined') {\n    // The target needs to be stored internally as a function, so that it can use the `apply` and `construct` handlers.\n    var targetFunc = function targetFunc() {\n      return target;\n    };\n\n    targetFunc._promise_chain_cache = Object.create(null);\n    return new Proxy(targetFunc, handlers);\n  }\n\n  return target;\n};\n\nif (typeof Proxy !== 'undefined') {\n  if (typeof Reflect === 'undefined') {\n    require('harmony-reflect');\n  }\n\n  handlers = {\n    get: function get(target, property) {\n      if (property === 'inspect') {\n        return function () {\n          return '[chainable Promise]';\n        };\n      }\n\n      if (property === '_raw') {\n        return target();\n      }\n\n      if (typeof property === 'symbol') {\n        return target()[property];\n      } // If the Promise itself has the property ('then', 'catch', etc.), return the property itself, bound to the target.\n      // However, wrap the result of calling this function. This allows wrappedPromise.then(something) to also be wrapped.\n\n\n      if (property in target()) {\n        if (property !== 'constructor' && !property.startsWith('_') && typeof target()[property] === 'function') {\n          return function () {\n            return wrap(target()[property].apply(target(), arguments));\n          };\n        }\n\n        return target()[property];\n      } // If the property has a value in the cache, use that value.\n\n\n      if (Object.prototype.hasOwnProperty.call(target._promise_chain_cache, property)) {\n        return target._promise_chain_cache[property];\n      } // If the Promise library allows synchronous inspection (bluebird, etc.), ensure that properties of resolved\n      // Promises are also resolved immediately.\n\n\n      if (target().isFulfilled && target().isFulfilled() && typeof target().value === 'function') {\n        return wrap(target().constructor.resolve(target().value()[property]));\n      } // Otherwise, return a promise for that property.\n      // Store it in the cache so that subsequent references to that property will return the same promise.\n\n\n      target._promise_chain_cache[property] = wrap(target().then(function (result) {\n        if (result && (typeof result === 'object' || typeof result === 'function')) {\n          return wrap(result[property]);\n        }\n\n        throw new TypeError(\"Promise chain rejection: Cannot read property '\" + property + \"' of \" + result + '.');\n      }));\n      return target._promise_chain_cache[property];\n    },\n    apply: function apply(target, thisArg, args) {\n      // If the wrapped Promise is called, return a Promise that calls the result\n      return wrap(target().constructor.all([target(), thisArg]).then(function (results) {\n        if (typeof results[0] === 'function') {\n          return wrap(Reflect.apply(results[0], results[1], args));\n        }\n\n        throw new TypeError('Promise chain rejection: Attempted to call ' + results[0] + ' which is not a function.');\n      }));\n    },\n    construct: function construct(target, args) {\n      return wrap(target().then(function (result) {\n        return wrap(Reflect.construct(result, args));\n      }));\n    }\n  }; // Make sure all other references to the proxied object refer to the promise itself, not the function wrapping it\n\n  Object.getOwnPropertyNames(Reflect).forEach(function (handler) {\n    handlers[handler] = handlers[handler] || function (target, arg1, arg2, arg3) {\n      return Reflect[handler](target(), arg1, arg2, arg3);\n    };\n  });\n}\n\nmodule.exports = wrap;","map":null,"metadata":{},"sourceType":"script"}