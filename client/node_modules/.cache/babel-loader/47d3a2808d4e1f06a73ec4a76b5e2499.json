{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rawRequest = undefined;\n\nvar _merge2 = require('lodash/merge');\n\nvar _merge3 = _interopRequireDefault(_merge2);\n\nvar _includes2 = require('lodash/includes');\n\nvar _includes3 = _interopRequireDefault(_includes2);\n\nexports.oauthRequest = oauthRequest;\nexports._awaitExponentialBackoff = _awaitExponentialBackoff;\nexports._awaitRatelimit = _awaitRatelimit;\nexports._awaitRequestDelay = _awaitRequestDelay;\nexports.credentialedClientRequest = credentialedClientRequest;\nexports.unauthenticatedRequest = unauthenticatedRequest;\nexports.updateAccessToken = updateAccessToken;\n\nvar _Promise = require('./Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _constants = require('./constants.js');\n\nvar _errors = require('./errors.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n* @summary Sends an oauth-authenticated request to the reddit server, and returns the server's response.\n* @desc **Note**: While this function primarily exists for internal use, it is exposed and considered a stable feature.\nHowever, keep in mind that there are usually better alternatives to using this function. For instance, this\nfunction can be used to send a POST request to the 'api/vote' endpoint in order to upvote a comment, but it's generally\neasier to just use snoowrap's [upvote function]{@link VoteableContent#upvote}.\n*\n* If you're using this function to access an API feature/endpoint that is unsupported by snoowrap, please consider [creating an\nissue for it](https://github.com/not-an-aardvark/snoowrap/issues) so that the functionality can be added to snoowrap more\ndirectly.\n* @param {object} options Options for the request. For documentation on these options, see the\n[Request API](https://www.npmjs.com/package/request). Supported options include `uri`, `qs`, `form`, `headers`, `method`,\n`auth`, and `body`. A default `baseUrl` parameter of `this.config().endpoint_domain` is internally included by default, so it\nis recommended that a `uri` parameter be used, rather than a `url` parameter with a\ndomain name.\n* @returns {Promise} A Promise that fulfills with reddit's response.\n* @memberof snoowrap\n* @instance\n* @example\n*\n* r.oauthRequest({uri: '/user/spez/about', method: 'get'}).then(console.log)\n* // => RedditUser { name: 'spez', link_karma: 9567, ... }\n*\n* // Note that this is equivalent to:\n* r.getUser('spez').fetch().then(console.log)\n*\n* // ######\n*\n* r.oauthRequest({uri: '/api/vote', method: 'post', form: {dir: 1, id: 't3_4fzg2k'}})\n* // equivalent to:\n* r.getSubmission('4fzg2k').upvote()\n*\n* // ######\n*\n* r.oauthRequest({uri: '/top', method: 'get', qs: {t: 'all'}})\n* // equivalent to:\n* r.getTop({time: 'all'})\n*/\n\n\nfunction oauthRequest(options) {\n  var _Promise$resolve$then,\n      _this = this;\n\n  var attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return (_Promise$resolve$then = _Promise2.default.resolve().then(function () {\n    return _this._awaitRatelimit();\n  }).then(function () {\n    return _this._awaitRequestDelay();\n  }).then(function () {\n    return _awaitExponentialBackoff(attempts);\n  }).then(function () {\n    return _this.updateAccessToken();\n  }).then(function (token) {\n    return _this.rawRequest((0, _merge3.default)({\n      json: true,\n      headers: {\n        'user-agent': _this.userAgent\n      },\n      baseUrl: 'https://oauth.' + _this._config.endpointDomain,\n      qs: {\n        raw_json: 1\n      },\n      auth: {\n        bearer: token\n      },\n      resolveWithFullResponse: true,\n      timeout: _this._config.requestTimeout,\n      transform: function transform(body, response) {\n        if (Object.prototype.hasOwnProperty.call(response.headers, 'x-ratelimit-remaining')) {\n          _this.ratelimitRemaining = +response.headers['x-ratelimit-remaining'];\n          _this.ratelimitExpiration = Date.now() + response.headers['x-ratelimit-reset'] * 1000;\n        }\n\n        _this._debug('Received a ' + response.statusCode + ' status code from a `' + response.request.method + '` request', 'sent to ' + response.request.uri.href + '. ratelimitRemaining: ' + _this.ratelimitRemaining);\n\n        return response;\n      }\n    }, options));\n  }).then(function (response) {\n    var populated = _this._populate(response.body);\n\n    if (populated && populated.constructor._name === 'Listing') {\n      populated._setUri(response.request.uri.href);\n    }\n\n    return populated;\n  })).catch.apply(_Promise$resolve$then, _toConsumableArray(this._config.retryErrorCodes.map(function (retryCode) {\n    return {\n      statusCode: retryCode\n    };\n  })).concat([function (e) {\n    if (!(0, _includes3.default)(_constants.IDEMPOTENT_HTTP_VERBS, e.response.request.method) || attempts >= _this._config.maxRetryAttempts) {\n      throw e;\n    }\n    /* If the error's status code is in the user's configured `retryStatusCodes` and this request still has attempts\n    remaining, retry this request and increment the `attempts` counter. */\n\n\n    _this._warn('Received status code ' + e.statusCode + ' from reddit.', 'Retrying request (attempt ' + (attempts + 1) + '/' + _this._config.maxRetryAttempts + ')...');\n\n    return _this.oauthRequest(options, attempts + 1);\n  }])).catch({\n    statusCode: 401\n  }, function (e) {\n    /* If the server returns a 401 error, it's possible that the access token expired during the latency period as this\n    request was being sent. In this scenario, snoowrap thought that the access token was valid for a few more seconds, so it\n    didn't refresh the token, but the token had expired by the time the request reached the server. To handle this issue,\n    invalidate the access token and call oauth_request again, automatically causing the token to be refreshed. */\n    if (_this.accessToken && _this.tokenExpiration - Date.now() < _constants.MAX_TOKEN_LATENCY) {\n      _this.accessToken = null;\n      _this.tokenExpiration = null;\n      return _this.oauthRequest(options, attempts);\n    }\n\n    throw e;\n  });\n}\n\nfunction _awaitExponentialBackoff(attempts) {\n  if (attempts === 1) {\n    return _Promise2.default.resolve();\n  }\n\n  return _Promise2.default.delay((Math.pow(2, attempts - 1) + (Math.random() - 0.3)) * 1000);\n}\n\nfunction _awaitRatelimit() {\n  if (this.ratelimitRemaining < 1 && Date.now() < this.ratelimitExpiration) {\n    // If the ratelimit has been exceeded, delay or abort the request depending on the user's config.\n    var timeUntilExpiry = this.ratelimitExpiration - Date.now();\n\n    if (this._config.continueAfterRatelimitError) {\n      /* If the `continue_after_ratelimit_error` setting is enabled, queue the request, wait until the next ratelimit\n      period, and then send it. */\n      this._warn((0, _errors.rateLimitWarning)(timeUntilExpiry));\n\n      return _Promise2.default.delay(timeUntilExpiry);\n    } // Otherwise, throw an error.\n\n\n    throw new _errors.RateLimitError(timeUntilExpiry);\n  } // If the ratelimit hasn't been exceeded, no delay is necessary.\n\n\n  return _Promise2.default.resolve();\n}\n\nfunction _awaitRequestDelay() {\n  var now = Date.now();\n  var waitTime = this._nextRequestTimestamp - now;\n  this._nextRequestTimestamp = Math.max(now, this._nextRequestTimestamp) + this._config.requestDelay;\n  return _Promise2.default.delay(waitTime);\n}\n/**\n* @summary Sends a request to the reddit server, authenticated with the user's client ID and client secret.\n* @desc **Note**: This is used internally as part of the authentication process, but it cannot be used to actually fetch\ncontent from reddit. To do that, use {@link snoowrap#oauthRequest} or another of snoowrap's helper functions.\n*\n* This function can work with alternate `this`-bindings, provided that the binding has the `clientId`, `clientSecret`, and\n`userAgent` properties. This allows it be used if no snoowrap requester has been created yet.\n* @param {object|string} options Options for the request; these are passed directly to the\n[Request API](https://www.npmjs.com/package/request).\n* @returns {Promise} The response from the reddit server\n* @example\n*\n* // example: this function could be used to exchange a one-time authentication code for a refresh token.\nsnoowrap.prototype.credentialedClientRequest.call({\n  clientId: 'client id goes here',\n  clientSecret: 'client secret goes here',\n  userAgent: 'user agent goes here'\n}, {\n  method: 'post',\n  baseUrl: 'https://www.reddit.com',\n  uri: 'api/v1/access_token',\n  form: {grant_type: 'authorization_code', code: 'code goes here', redirect_uri: 'redirect uri goes here'}\n}).then(response => {\n  //handle response here\n})\n* @memberof snoowrap\n* @instance\n*/\n\n\nfunction credentialedClientRequest(options) {\n  var requestFunc = this.rawRequest || rawRequest;\n  return _Promise2.default.resolve(requestFunc.call(this, (0, _merge3.default)({\n    json: true,\n    auth: {\n      user: this.clientId || this.client_id || '',\n      pass: this.clientSecret || this.client_secret || ''\n    },\n    headers: {\n      'user-agent': this.userAgent\n    },\n    baseUrl: this._config ? 'https://www.' + this._config.endpointDomain : undefined\n  }, options)));\n}\n/**\n* @summary Sends a request to the reddit server without authentication.\n* @param {object|string} options Options for the request; these are passed directly to the\n[Request API](https://www.npmjs.com/package/request).\n* @returns {Promise} The response from the reddit server\n* @memberof snoowrap\n* @instance\n*/\n\n\nfunction unauthenticatedRequest(options) {\n  return _Promise2.default.resolve(this.rawRequest((0, _merge3.default)({\n    json: true,\n    headers: {\n      'user-agent': this.userAgent\n    },\n    baseUrl: 'https://www.' + this._config.endpointDomain\n  }, options)));\n}\n/**\n* @summary Updates this requester's access token if the current one is absent or expired.\n* @desc **Note**: This function is automatically called internally when making a request. While the function is exposed as\na stable feature, using it is rarely necessary unless an access token is needed for some external purpose.\n* @returns {Promise} A Promise that fulfills with the access token when this request is complete\n* @memberof snoowrap\n* @instance\n* @example r.updateAccessToken()\n*/\n\n\nfunction updateAccessToken() {\n  var _this2 = this; // If the current access token is missing or expired, and it is possible to get a new one, do so.\n\n\n  if ((!this.accessToken || Date.now() > this.tokenExpiration) && (this.refreshToken || this.username && this.password)) {\n    return this.credentialedClientRequest({\n      method: 'post',\n      uri: 'api/v1/access_token',\n      form: this.refreshToken ? {\n        grant_type: 'refresh_token',\n        refresh_token: this.refreshToken\n      } : {\n        grant_type: 'password',\n        username: this.username,\n        password: this.password\n      }\n    }).then(function (tokenInfo) {\n      _this2.accessToken = tokenInfo.access_token;\n      _this2.tokenExpiration = Date.now() + tokenInfo.expires_in * 1000;\n\n      if (tokenInfo.error === 'invalid_grant') {\n        throw new Error('\"Invalid grant\" error returned from reddit. (You might have incorrect credentials.)');\n      } else if (tokenInfo.error_description !== undefined) {\n        throw new Error('Reddit returned an error: ' + tokenInfo.error + ': ' + tokenInfo.error_description);\n      } else if (tokenInfo.error !== undefined) {\n        throw new Error('Reddit returned an error: ' + tokenInfo.error);\n      }\n\n      _this2.scope = tokenInfo.scope.split(' ');\n      return _this2.accessToken;\n    });\n  } // Otherwise, just return the existing token.\n\n\n  return _Promise2.default.resolve(this.accessToken);\n}\n/**\n* @function\n* @name rawRequest\n* @summary Sends an HTTP request\n* @desc **Note**: This function is called internally whenever snoowrap makes a request. You generally should not call this\n* function directly; use {@link snoowrap#oauthRequest} or another snoowrap function instead.\n*\n* This method allows snoowrap's request behavior to be customized via subclassing. If you create a snoowrap subclass and shadow\n* this method, all requests from snoowrap will pass through it.\n*\n* To ensure that all other snoowrap methods work correctly, the API for a shadowed version of this method must match the API for\n* the original `makeRequest` method. This method is based on the API of the\n* [request-promise](https://www.npmjs.com/package/request-promise) library, so if you do create a subclass, it might be helpful\n* to use `request-promise` internally. This will ensure that the API works correctly, so that you don't have to reimplement this\n* function's API from scratch.\n*\n* @param {object} options Options for the request\n* @param {boolean} options.json If `true`, the `Content-Type: application/json` header is added, and the response body will be\n* parsed as JSON automatically.\n* @param {string} options.baseUrl The base URL that a request should be sent to\n* @param {string} options.uri The uri that a request should be sent to, using the provided `baseUrl`.\n* @param {string} options.method='GET' Method for the request\n* @param {object} options.headers Headers for the request\n* @param {object} [options.qs] Querystring parameters for the request\n* @param {object} [options.form] Form data for the request. If provided, the `Content-Type: application/x-www-form-urlencoded`\n* header is set, and the provided object is serialized into URL-encoded form data in the request body.\n* @param {object} [options.formData] Multipart form data for the request. If provided, the `Content-Type: multipart/form-data`\n* header is set, and the provided object is serialized as multipart form data.\n* @param {object} [options.body] The body of the request. Should be converted to a string with JSON.stringify(). This is ignored\n* for GET requests, or of `options.form` or `options.formData` are provided.\n* @param {Function} [options.transform] A function that is called before the response Promise fulfills. Accepts two parameters:\n* `response.body` and `response`. This function should be called regardless of the status code of the response, and the returned\n* Promise from `makeRequest` should fulfill with its return value.\n* @param {boolean} [options.resolveWithFullResponse=false] If `true`, a Promise for the entire response is returned. If `false`,\n* a Promise for only the response body is returned. This is ignored if an `options.transform` function is provided.\n* @returns {Promise} A Promise for a response object. Depending on `options.transform` and `options.resolveWithFullResponse`,\n* the Promise should settle with either the response object itself, the body of the response, or the value returned by\n* `options.transform`. The Promise should be fulfilled if the status code is between 200 and 299, inclusive, and reject\n* otherwise. (If a redirect is returned from the server, the function should follow the redirect if possible, otherwise reject\n* with an error.) A response object has 4 properties: `statusCode` (number) the status code of the response, `body` (object)\n* the body of the response, `headers` (object) the parsed response headers, and `request` (object) an object of the form\n* `{method: 'GET', uri: {href: 'https://oauth.reddit.com/full/url'}}` representing information about the original request.\n* @memberof snoowrap\n* @instance\n* @example\n*\n* const snoowrap = require('snoowrap');\n*\n* class SnoowrapSubclass extends snoowrap {\n*   rawRequest(options) {\n*     // do custom behavior with `options` if you want, then call the regular rawRequest function\n*     console.log(`made a request with options:`);\n*     console.log(options);\n*     return super.rawRequest(options)\n*   }\n* }\n*\n* const request = require('request-promise');\n*\n* class AnotherSnoowrapSubclass extends snoowrap {\n*   rawRequest(options) {\n*     // send all requests through a proxy\n*     return request(Object.assign(options, {proxy: 'https://example.com'}))\n*   }\n* }\n*/\n\n\nvar rawRequest = exports.rawRequest = typeof XMLHttpRequest !== 'undefined' ? require('./xhr') : require('request-promise').defaults({\n  gzip: true\n});","map":null,"metadata":{},"sourceType":"script"}