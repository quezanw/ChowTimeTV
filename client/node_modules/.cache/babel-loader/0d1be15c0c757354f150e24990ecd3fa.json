{"ast":null,"code":"'use strict';\n\nvar _Promise = require('./Promise.js');\n\nvar _Promise2 = _interopRequireDefault(_Promise);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _querystring = require('querystring');\n\nvar _errors = require('./errors.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Provide a shim for some of the functionality of the `request-promise` npm package in browsers.\n// Previously, snoowrap depended on browserify to package `request-promise` for the browser bundle, and while this worked\n// properly, it caused the snoowrap bundle to be very large since `request-promise` contains many dependencies that snoowrap\n// doesn't actually need.\n\n/* eslint-env browser */\n\n\nfunction noop() {}\n\nfunction tryParseJson(maybeJson) {\n  try {\n    return JSON.parse(maybeJson);\n  } catch (e) {\n    return maybeJson;\n  }\n}\n\nfunction parseHeaders(headerString) {\n  return headerString.split('\\r\\n').filter(function (line) {\n    return line;\n  }).reduce(function (accumulator, line) {\n    var index = line.indexOf(': ');\n    accumulator[line.slice(0, index)] = line.slice(index + 2);\n    return accumulator;\n  }, {});\n}\n\nmodule.exports = function rawRequest(options) {\n  // It would be nice to be able to use the `URL` API in browsers, but Safari 9 doesn't support `URLSearchParams`.\n  var parsedUrl = _url2.default.parse(options.url || _url2.default.resolve(options.baseUrl, options.uri), true);\n\n  parsedUrl.search = (0, _querystring.stringify)(Object.assign({}, parsedUrl.query, options.qs)); // create a new url object with the new qs params, to ensure that the `href` value changes (to use later for parsing response)\n\n  var finalUrl = _url2.default.parse(parsedUrl.format());\n\n  var xhr = new XMLHttpRequest();\n  var method = options.method ? options.method.toUpperCase() : 'GET';\n  xhr.open(method, finalUrl.href);\n  Object.keys(options.headers).filter(function (header) {\n    return header.toLowerCase() !== 'user-agent';\n  }).forEach(function (key) {\n    return xhr.setRequestHeader(key, options.headers[key]);\n  });\n\n  if (options.auth) {\n    xhr.setRequestHeader('Authorization', options.auth.bearer ? 'bearer ' + options.auth.bearer : 'basic ' + btoa(options.auth.user + ':' + options.auth.pass));\n  }\n\n  var requestBody = void 0;\n\n  if (options.formData) {\n    requestBody = new FormData();\n    Object.keys(options.formData).forEach(function (key) {\n      return requestBody.append(key, options.formData[key]);\n    });\n\n    if (options.form) {\n      Object.keys(options.form).forEach(function (key) {\n        return requestBody.append(key, options.form[key]);\n      });\n    }\n\n    xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n  } else if (options.form) {\n    requestBody = (0, _querystring.stringify)(options.form);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  } else if (options.json) {\n    requestBody = JSON.stringify(options.body);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n  } else {\n    requestBody = options.body;\n  }\n\n  return new _Promise2.default(function (resolve, reject, onCancel) {\n    onCancel(function () {\n      return xhr.abort();\n    });\n\n    xhr.onload = function () {\n      var _this = this;\n\n      var success = this.status >= 200 && this.status < 300;\n      var settleFunc = success ? resolve : function (err) {\n        return reject(Object.assign(new _errors.StatusCodeError(_this.status + ''), err));\n      };\n      var response = {\n        statusCode: this.status,\n        body: (options.json ? tryParseJson : noop)(xhr.response),\n        headers: parseHeaders(xhr.getAllResponseHeaders()),\n        request: {\n          method: method,\n          uri: finalUrl\n        }\n      };\n\n      if (typeof options.transform === 'function') {\n        settleFunc(options.transform(response.body, response));\n      } else if (!success || options.resolveWithFullResponse) {\n        settleFunc(response);\n      } else {\n        settleFunc(response.body);\n      }\n    };\n\n    xhr.onerror = function (err) {\n      return reject(Object.assign(new _errors.RequestError(), err));\n    };\n\n    xhr.send(requestBody);\n  }).timeout(options.timeout || Math.pow(2, 31) - 1, 'Error: ETIMEDOUT').catch(_Promise2.default.TimeoutError, function (err) {\n    xhr.abort();\n    throw err;\n  });\n};","map":null,"metadata":{},"sourceType":"script"}